<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Project5 YDEX</title>
      <link href="/2023/04/14/project5/"/>
      <url>/2023/04/14/project5/</url>
      
        <content type="html"><![CDATA[<h1 id="📈-YDEX-PROJECT"><a href="#📈-YDEX-PROJECT" class="headerlink" title="📈 YDEX PROJECT"></a>📈 YDEX PROJECT</h1><h2 id="1-팀-소개"><a href="#1-팀-소개" class="headerlink" title="1. 팀 소개"></a>1. 팀 소개</h2><h3 id="BCC-03-02조"><a href="#BCC-03-02조" class="headerlink" title="BCC-03-02조"></a>BCC-03-02조</h3><ul><li><p><strong>팀 명 : YDEX</strong></p></li><li><p><strong>프로젝트 명 : YDEX</strong></p></li><li><p><strong>팀장 : 홍유진</strong></p></li><li><p><strong>팀원 : 김윤겸</strong></p></li><li><p><strong>Github Repo : <a href="https://github.com/yu-uj/YDEX">https://github.com/yu-uj/YDEX</a></strong></p></li><li><p><strong>프로젝트 진행 기간 : 2022&#x2F;10&#x2F;18 - 2022&#x2F;11&#x2F;04</strong></p></li><li><p><strong>프로젝트 내용</strong> <strong>:</strong> JDEX를 리팩토링하여 토큰 이코노미 강화</p></li><li><p><strong>팀 룰</strong></p><p>  → 매일 오전 10시, 오후 5시 필수 회의 진행회의록 작성</p><p>  → 회의록 작성</p><p>  → 그 날의 진행 계획 및 진행 중인 상황 공유</p></li></ul><br/><h2 id="2-프로젝트-개요"><a href="#2-프로젝트-개요" class="headerlink" title="2. 프로젝트 개요"></a>2. 프로젝트 개요</h2><h2 id="💸-YDEX-프로젝트-목표"><a href="#💸-YDEX-프로젝트-목표" class="headerlink" title="💸 YDEX 프로젝트 목표"></a>💸 <strong>YDEX 프로젝트 목표</strong></h2><h3 id="→-Klaytn-기반의-JDEX-탈중앙화거래소-Code-Refactoring"><a href="#→-Klaytn-기반의-JDEX-탈중앙화거래소-Code-Refactoring" class="headerlink" title="→ Klaytn 기반의 JDEX(탈중앙화거래소) Code Refactoring."></a>→ <em>Klaytn 기반의 JDEX(탈중앙화거래소) Code Refactoring.</em></h3><blockquote><p><strong>JDEX 참고 링크</strong> : <a href="https://github.com/yu-uj/JDEX">https://github.com/yu-uj/JDEX</a></p></blockquote><h3 id="→-De-fi적-기능-추가-구현으로-토큰-이코노미-보강"><a href="#→-De-fi적-기능-추가-구현으로-토큰-이코노미-보강" class="headerlink" title="→ De-fi적 기능 추가 구현으로 토큰 이코노미 보강."></a>→ <em>De-fi적 기능 추가 구현으로 토큰 이코노미 보강.</em></h3><aside>➡️ DEX; (Decentralized Exchange)<p><strong>기존의 중앙화거래소(CEX)가 아닌 개인 간 금융(P2P)이 가능한 탈중앙화(분산형) 거래소.</strong> 법정화폐와 암호화폐간의 교환을 허용하지 않고, 암호화폐 토큰을 다른 암호화폐 토큰과 거래하여 블록체인(분산 원장) 위에 구축 및 기록된 <strong>스마트계약의 집합</strong>이다.</p></aside><br/><h2 id="💸-YDEX-란"><a href="#💸-YDEX-란" class="headerlink" title="💸 YDEX 란 ?"></a>💸 <strong>YDEX</strong> 란 ?</h2><blockquote><p>이젠 <strong>직접 자산을 관리하고 예치</strong>하세요.</p></blockquote><p><strong>YDEX</strong>는 기존의 중앙화된 거래소의 제삼자 개입 없이 <strong>개인 간 금융(P2P) 거래가 가능한 탈중앙화 거래소</strong> 입니다.</p><p>누구나 YDEX 웹 사이트에 방문하여 <strong>지갑</strong>(Kaikas)를 연결하고 보유하고 있는 토큰을 다른 사용자에게 <strong>전송</strong>하거나 다른 토큰으로 <strong>교환</strong> 할 수 있습니다.</p><p>보유 토큰을 토큰 페어쌍으로 유동성을 제</p><p>또, 토큰을 지갑에 가지고만 있는 것이 아닌, <strong>단일 풀에 예치</strong>하고, 예치한 토큰 가치의 150% 만큼 <strong>클레이를 대출</strong>할 수 있습니다.</p><p><strong>토큰 페어쌍으로 유동성 제공 후, 해당 토큰 페어의 LP토큰</strong>을 받아, <strong>페어 풀에 예치</strong>하여 에 대한 <strong>보상</strong>(YDEXToken)을 얻을 수 있습니다.</p><p><strong>YDEXToken</strong>은 단일 풀에 예치하여 lending 서비스를 이용하거나, <strong>NFT Marketplace</strong>를 통해 <strong>NFT 민팅</strong>하는데 사용하여 부가적인 수익을 창출할 수 있습니다.</p><br/><h2 id="💸-YDEX-의-대표-기능"><a href="#💸-YDEX-의-대표-기능" class="headerlink" title="💸 YDEX 의 대표 기능"></a>💸 <strong>YDEX</strong> 의 대표 기능</h2><ul><li><p><strong>My Token</strong></p><p>  : 소유하고 있는 토큰 목록을 확인하고, 다른 사람에게 원하는 토큰을 <strong>전송</strong> 할 수 있습니다.</p></li><li><p><strong>Swap</strong></p><p>  : 소유하고 있는 토큰을 다른 토큰들로 <strong>교환</strong>할 수 있습니다.</p></li><li><p><strong>Add Liquidity</strong></p><p>  : 소유하고 있는 토큰을 토큰 페어쌍으로 <strong>유동성을 제공</strong>하여 <strong>해당 토큰 페어의 LP 토큰</strong>을 받을 수 있습니다.</p></li><li><p><strong>Single Staking</strong></p><p>  : 토큰을 <strong>단일 풀</strong>에 <strong>예치</strong>하고, 해당 토큰 가치의 <strong>150% 만큼 클레이를 대출</strong>할 수 있습니다.</p></li><li><p><strong>Pair(LP) Staking</strong></p><p>  : 소유하고 있는 <strong>LP 토큰</strong>을 <strong>페어 풀</strong>에 <strong>예치</strong>하여 <strong>’YDEXTOken(플랫폼 토큰)’을 보상</strong>으로 받을 수 있습니다.</p></li><li><p><strong>NFT Marketplace</strong></p><p>  : <strong>예치 보상</strong>으로 받은 <strong>YDEX 토큰</strong>으로 <strong>NFT 민팅</strong>을 하고, <strong>NFT를 거래</strong>할 수 있습니다.</p></li></ul><br/><h2 id="💸-YDEX-채택-체인"><a href="#💸-YDEX-채택-체인" class="headerlink" title="💸 YDEX 채택 체인"></a>💸 <strong>YDEX 채택 체인</strong></h2><h3 id="⛓️-왜-Klaytn-인가"><a href="#⛓️-왜-Klaytn-인가" class="headerlink" title="⛓️ 왜 Klaytn 인가 ?"></a>⛓️ 왜 Klaytn 인가 ?</h3><ol><li><strong>저비용</strong><ol><li>트랜잭션에서 발생하는 <strong>가스비가 1~20원 수준</strong>으로, <strong>이더리움의 1&#x2F;100</strong>에 해당하는 가스 비용을 필요로 하여 매우 저렴합니다.</li></ol></li><li><strong>높은 확장성(TPS)</strong><ol><li>Klaytn은 실제 <strong>4000TPS</strong>의 트랜잭션 처리량을 가집니다. 이는 <strong>1초에 4000트랜잭션이 한 블록에 들어가는 확장성</strong>으로, 20TPS(Block Interval 15초)의 이더리움과 7TPS(Block Interval 10분)의 비트코인에 비교했을 때 월등히 높은 TPS 입니다.</li></ol></li><li><strong>짧은 완결성(Finality)</strong><ol><li>완결성은 <strong>블록에 담긴 거래가 바뀔 수 없다는 것을 보증하는 시간</strong>으로, 블록 생성 간격(Block Interval) * 검증 횟수로 계산합니다. 클레이튼은 <strong>1초의 완결성</strong>을 가져 초당 한 건의 <strong>합의와 동시에 처리</strong>합니다. 이더리움의 6분, 비트코인의 60분과 비교하여 매우 짧은 완결성을 가집니다.</li></ol></li><li><strong>새로운 시도</strong><ol><li>Klaytn에 비하여 ETH는 접할 기회가 많았기 때문에 이번 프로젝트를 통해 <strong>Klaytn Chain을 경험</strong>하고, 배우고 싶었습니다.</li></ol></li></ol><br/><h3 id="⛓️-왜-Klaytn-기반의-DEX인가"><a href="#⛓️-왜-Klaytn-기반의-DEX인가" class="headerlink" title="⛓️ 왜 Klaytn 기반의 DEX인가 ?"></a>⛓️ 왜 Klaytn 기반의 DEX인가 ?</h3><ol><li>기존의 보편화 된 덱스들은 이더리움의 메이저 덱스인 <strong>유니스왑</strong> 혹은 <strong>스시스왑</strong>을 클론 코딩하여 배포하였습니다. <strong>JDEX</strong>는 Klaytn에서 자체적으로 제공하는 <strong>Klaytn Dex Contracts</strong>를 분석하고, 배포하는 과정을 거쳐 KIP 컨트랙트 대신 이더리움의 ERC 컨트랙트를 수정하여 사용한 기존 Klaytn 덱스들과 <strong>차별점</strong>을 두었습니다.</li><li><strong>개인 간 금융</strong>(P2P)이 이루어지는 DEX에서 저희가 중요하게 생각한 2가지 <strong>수수료</strong>와 <strong>전송 속도</strong>입니다. 탈중앙화 거래소(DEX)인 만큼 중앙화거래소(은행)과는 다른 장점이 있어야 한다고 생각했고, 수업을 통해 배운 ETH는 비싼 수수료와 느린 전송 속도로 체인으로의 뚜렷한 장점을 찾지 못하였습니다. 그래서 상대적으로 <strong>가스비가 저렴</strong>하고, <strong>속도가 빠른 Klaytn Chain</strong>을 선택하게 되었습니다.</li></ol><br/><hr><h2 id="3-기능별-시연-영상"><a href="#3-기능별-시연-영상" class="headerlink" title="3. 기능별 시연 영상"></a>3. 기능별 시연 영상</h2><ul><li><p><strong>Connect Wallet</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201844099-0527dc04-3124-4bbd-9b35-5eff6a7eb985.gif" alt="ConnectWallet"></p><ul><li>Kailkas 지갑 연결을 위한 모달 창을 보여줍니다.</li></ul></li><li><p><strong>My Token</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201844183-bc59167e-eec2-4d6f-addf-212f26e16287.gif" alt="MyToken"></p><ul><li><strong>My Token List</strong><ul><li>연결된 지갑 보유한 Klay 토큰 및 KIP7 토큰 리스트업 합니다.</li></ul></li><li><strong>Transfer - 토큰 전송</strong><ul><li>보유한 토큰을 다른 사람에게 전송할 수 있습니다.</li></ul></li></ul></li><li><p><strong>Swap</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201844260-4b978352-a420-4dee-9211-2211bf3e79d7.gif" alt="Swap"></p><ul><li>보유한 Klay &#x2F; KIP7 토큰을 원하는 다른 KIP7 토큰으로 교환 할 수 있습니다.</li></ul></li><li><p><strong>Add Liquidity</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201844408-b5e459e4-eff7-4e6d-9ca2-009526be3244.gif" alt="AddLiquidity"></p><ul><li>Klay &#x2F; KIP7 토큰 페어쌍을 선택하여 유동성을 공급하고 해당 토큰 페어의 LP 토큰을 받을 수 있습니다.</li></ul></li><li><p><strong>Single Staking - 단일 예치</strong></p><ul><li><p>토큰을 단일 예치하고, Lending 서비스를 이용할 수 있습니다.</p></li><li><p><strong>Single Pool List</strong></p><p>  <strong>[ Deposit - 예치 ]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201844933-288fd1a4-4b9e-4413-bbe3-3940f4cf0a6c.gif" alt="SingleDeposit"></p><p>  <strong>[ Withdraw - 출금 ]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201844966-add8992b-9de0-4305-9eba-34755a1ddd06.gif" alt="SingleWithdraw"></p><p>  <strong>[ Borrow - 대출 &#x2F; RePay - 상환  ]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201845671-c4eab4a5-a1c3-47ee-8278-5585516741df.gif" alt="SingleLending"></p><ul><li>단일 풀 목록이 리스트 업 됩니다.</li><li>풀을 선택하여 단일 예치(Deposit)와 출금(Withdraw)가 가능합니다.</li><li>예치한 토큰 가치의 150% 만큼 Klay를 대출 받고, 상환할 수 있습니다.</li></ul></li></ul></li><li><p><strong>Pair Staking - 페어 예치</strong></p><ul><li><p>보유한 LP 토큰을 예치하고, 유동성에 대한 보상(YDEXToken : Platform Token)을 받습니다.</p></li><li><p><strong>Pair Pool List</strong></p><p>  <strong>[ Deposit - 예치 ]</strong></p><p> <img src="https://user-images.githubusercontent.com/99964401/201846419-2edfe123-9e25-439b-8f4f-e39d92919a90.gif" alt="PairDeposit"></p><p>  <strong>[ Withdraw - 출금 ]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201846495-49a39003-9862-4fab-a926-154f7607fdae.gif" alt="PairWithdraw"></p><ul><li>ALL &#x2F; Klay &#x2F; KIP 페어 풀 목록이 리스트 업 됩니다.</li><li>원하는 페어 풀을 선택하여 LP 토큰 예치(Deposit)와 출금(Withdraw)가 가능합니다.</li></ul></li><li><p><strong>Create Pool</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193565047-24599c7c-2e84-4a2a-b995-0fbd10f6f177.gif" alt="create"></p><ul><li>원하는 토큰 페어의 유동성 풀을 생성할 수 있습니다.</li></ul></li><li><p><strong>NFT Marketplace</strong></p><p> <img src="https://user-images.githubusercontent.com/99964401/201846760-70c2c7f9-38a1-4289-9348-e8dff27cae1b.gif" alt="NFTMarket"></p><ul><li>예치 보상으로 받은 YDEXToken을 사용하여 NFT를 민팅하고, 거래할 수 있습니다.</li></ul></li></ul></li></ul><br/><hr><br/><h2 id="4-관련-문서"><a href="#4-관련-문서" class="headerlink" title="4. 관련 문서"></a>4. 관련 문서</h2><h3 id="📋-DB-Schema"><a href="#📋-DB-Schema" class="headerlink" title="📋 DB Schema"></a>📋 DB Schema</h3><img width="613" alt="DB" src="https://user-images.githubusercontent.com/99964401/193568157-2b32a512-8f18-4274-b14f-9d59167e2f0a.png"><br/><h3 id="📋-DB-API-리스트"><a href="#📋-DB-API-리스트" class="headerlink" title="📋 DB API 리스트"></a>📋 DB API 리스트</h3><img width="698" alt="API_List" src="https://user-images.githubusercontent.com/99964401/193606675-3742b16f-c9fc-49aa-9127-11a96ad83b4b.png"><br/><h3 id="📋-Flow-Chart"><a href="#📋-Flow-Chart" class="headerlink" title="📋 Flow Chart"></a>📋 Flow Chart</h3><p><img src="https://user-images.githubusercontent.com/99964401/201847182-a4cd54ce-a9a6-4d96-bf5b-caca8552d81e.png" alt="YDEX drawio"></p><br/><h3 id="📋-Token-Economy"><a href="#📋-Token-Economy" class="headerlink" title="📋 Token Economy"></a>📋 Token Economy</h3><img width="1709" alt="YDEX_TokenEconomy" src="https://user-images.githubusercontent.com/99964401/193568712-eba90a3c-1c83-4d93-9294-a3795ec1a5b1.png"><p><strong>[YDEX의 Token Economy]</strong></p><ul><li><strong>개발자, 투자자, 유저</strong>들에게 적절한 양의 <strong>토큰을 분배</strong>하고, <strong>예치</strong>(단일, 페어 풀)에 대한 <strong>보상</strong>으로 <strong>YDEX토큰을 지급</strong> 받습니다.</li><li>보상으로 주어지는 <strong>YDEX토큰</strong>을 <strong>일정 지분 보유</strong>시 <strong>YDEX의 운영 방향성 및 협의</strong>에 대한 <strong>투표 거버넌스에 참여</strong>할 수 있습니다.</li><li>YDEX토큰은 <strong>풀에 예치</strong>한 순간부터 <strong>블록당 보상</strong>이 제공되고, 보상으로 받는 YDEX토큰을 <strong>단일 풀</strong>에 예치하여 <strong>Klay를 대출받는 시스템과 NFT 민팅 및 거래에 사용</strong>합니다. </li><li><strong>토큰 스왑 수수료</strong> 0.3%와 <strong>NFT 민팅과 거래에 사용되는 수수료</strong>를 <strong>바이백 펀드를 활용</strong>하여 YDEX 토큰을 <strong>소각</strong>하는 등으로 지속가능한 시스템을 구축하였습니다.</li></ul><br/><hr><div align=center><h1>📚 YDEX STACKS</h1></div><div align=center>   <div align=center><h3>COLLABORATION TOOL</h3></div>  <img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">  <img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">  <img src="https://img.shields.io/badge/discord-5865F2?style=for-the-badge&logo=discord&logoColor=white">  <img src="https://img.shields.io/badge/notion-000000?style=for-the-badge&logo=notion&logoColor=white">  <br>    <div align=center><h3>FRONTEND</h3></div>  <img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white">   <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black">   <img src="https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=black">  <img src="https://img.shields.io/badge/bootstrap-7952B3?style=for-the-badge&logo=bootstrap&logoColor=white">   <br>  <img src="https://img.shields.io/badge/typescript-3178C6?style=for-the-badge&logo=typescript&logoColor=white">  <img src="https://img.shields.io/badge/axios-5A29E4?style=for-the-badge&logo=axios&logoColor=white">  <img src="https://img.shields.io/badge/redux-764ABC?style=for-the-badge&logo=redux&logoColor=white">  <img src="https://img.shields.io/badge/Caver-005A2B?style=for-the-badge&logo=Caver&logoColor=white">  <img src="https://img.shields.io/badge/figma-F24E1E?style=for-the-badge&logo=redux&logoColor=white">  <br>    <div align=center><h3>BACKEND</h3></div>  <img src="https://img.shields.io/badge/node.js-339933?style=for-the-badge&logo=Node.js&logoColor=white">  <img src="https://img.shields.io/badge/express-000000?style=for-the-badge&logo=express&logoColor=white">  <img src="https://img.shields.io/badge/mongoDB-47A248?style=for-the-badge&logo=MongoDB&logoColor=white">  <img src="https://img.shields.io/badge/Mongoose-D0021B?style=for-the-badge&logo=Mongoose&logoColor=white">  <img src="https://img.shields.io/badge/.env-ECD53F?style=for-the-badge&logo=.env&logoColor=white">  <br>    <div align=center><h3>BLOCKCHAIN</h3></div>  <img src="https://img.shields.io/badge/solidity-363636?style=for-the-badge&logo=solidity&logoColor=white">  <img src="https://img.shields.io/badge/hardhat-124191?style=for-the-badge&logo=hardhat&logoColor=white">  <img src="https://img.shields.io/badge/truffle-840010?style=for-the-badge&logo=truffle&logoColor=white">  <img src="https://img.shields.io/badge/Kaikas-F5AE29?style=for-the-badge&logo=Kailkas&logoColor=black">  <img src="https://img.shields.io/badge/KlaytnIDE-003366?style=for-the-badge&logo=KlaytnIDE&logoColor=white">  <img src="https://img.shields.io/badge/ganache-A42E2B?style=for-the-badge&logo=ganache&logoColor=white">  <br>  </div><!-- pdf parameters---urlcolor: #e3232clinkcolor: #e3232c-----><!-- start intro: only for github, remove if creating a pdf --><hr><h2 id="프로젝트-회고"><a href="#프로젝트-회고" class="headerlink" title="프로젝트 회고"></a>프로젝트 회고</h2><h3 id="느낀점"><a href="#느낀점" class="headerlink" title="느낀점"></a>느낀점</h3><p>이번 프로젝트는 JDEX를 구현하면서 아쉬웠던 토큰 이코노미 구상과 프론트엔드 코드 부분을 리팩토링 할 수 있어서 의미있는 프로젝트였다.<br>JDEX는 클레이튼 체인을 통해 탈중앙화 암호화폐거래소가 갖춰야할 기본적인 세가지 기능을 구현하는 것이 목표였다.<br>때문에 기능별로 한 페이지에 작성된 어설픈 프론트 코드와 LP풀에 토큰을 예치와 동시에 유동성을 제공하는 것, 지속적인 생태계를 갖출 수 있는 토큰 이코노미가 아쉬웠다.<br>프론트엔드에서는 기존 사용했던 리액트 부트스트랩이 카드뷰에서 리스트업 방식으로 데이터를 호출하는 것이 지원되지 않았다.<br>이외의 화면 구성에 있어서 자유도가 매우 낮았기 때문에 이전 프로젝트를 통해 접해본 Mui를 도입하여 리팩토링을 진행했다.<br>또한, 길었던 코드 길이를 컴포넌트 단위로 세부적으로 나눠 유지보수성을 높일 수 있었다.<br>기능적인 면으로는 스마트 컨트랙트를 재발행하고, 페이지를 나눠 페어풀 예치와 유동성 공급 기능을 분리하였다.<br>토큰 이코노미는 팀원들과 많은 상의를 했고, 예치 보상으로 주어지는 플랫폼 토큰을 사용하여 사용자들이 수익성을 얻을 수 있도록 고민했다.<br>최종적으로 NFT를 민팅할 수 있는 마켓 플레이스 기능과 Klay를 일정 비율로 대출할 수 있는 Lending 서비스를 구현했다.</p><br/><p>마지막으로 이번 프로젝트에 대한 회고를 하자면,<br>팀 리더로써 팀원들과 최대한의 소통을 진행했다고 생각했는데 부족했다.<br>팀원이 아닌 팀장으로 팀을 목표로 이끌기 위해 좀더 단호하게 말하는 방법이 필요했다.<br>또한, 서로 진행한 결과물을 확인할 시간이 반드시 있어야 한다.<br>중간 중간 merge를 통해 다른 팀원이 진행한 부분과 merge에 있어 문제가 없는지 확인하는 단계는 필수다.<br>여러모로 YDEX는 완성한 뿌듯함과 동시에 반성을 많이 하게 된 프로젝트였다.</p><hr></br>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> project </tag>
            
            <tag> codestate </tag>
            
            <tag> Klaytn </tag>
            
            <tag> BCC03 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project4 Bithumb Dagao Neo</title>
      <link href="/2023/04/13/project4/"/>
      <url>/2023/04/13/project4/</url>
      
        <content type="html"><![CDATA[<h1 id="Bithumb-Dagao-Neo-빗썸이-다가오네오"><a href="#Bithumb-Dagao-Neo-빗썸이-다가오네오" class="headerlink" title="Bithumb Dagao Neo (빗썸이 다가오네오)"></a>Bithumb Dagao Neo (빗썸이 다가오네오)</h1><p><img src="https://user-images.githubusercontent.com/104472372/201553707-80392876-a7cd-48d6-801a-14ce7467e375.png"></p><h2 id="1-팀-소개"><a href="#1-팀-소개" class="headerlink" title="1. 팀 소개"></a>1. 팀 소개</h2><ul><li><p><strong>팀 명 : (빗)썸 타고싶다</strong></p></li><li><p><strong>프로젝트 명 : Bithumb Dagao Neo (빗썸이 다가오네오)</strong></p></li><li><p><strong>팀장 : 오하영</strong></p></li><li><p><strong>팀원 : 홍유진, 정웅섭, 이종환</strong></p></li><li><p><strong>Github Repo :</strong> <a href="https://github.com/yu-uj/Bithumb-Dagao-NEO">https://github.com/yu-uj/Bithumb-Dagao-NEO</a></p></li><li><p>진행 기간 <strong>: 2022&#x2F;10&#x2F;31 - 2022&#x2F;11&#x2F;13</strong></p></li><li><p><strong>프로젝트 내용 :</strong> 하나의 체인을 선정하여, 크롬 익스텐션 월렛(Wallet) &#x2F; 탐색기 (Explorer) &#x2F; Node 운영 및 구현</p></li><li><p><strong>맡은 역할</strong></p><ul><li>Wallet 구현</li></ul></li><li><p><strong>팀 룰</strong></p><p>  → 매일 오후 7시 필수 회의</p><p>  → 그 날의 진행 계획 및 진행 중인 상황 공유</p></li></ul><br/><hr><h2 id="선정-코인-소개-NEO"><a href="#선정-코인-소개-NEO" class="headerlink" title="선정 코인 소개 (NEO)"></a>선정 코인 소개 (NEO)</h2><h3 id="📟-프로젝트-개요"><a href="#📟-프로젝트-개요" class="headerlink" title="📟 프로젝트 개요"></a>📟 프로젝트 개요</h3><blockquote><p><strong>스마트 이코노미를 위한 분산 네트워크</strong></p></blockquote><blockquote><p><strong>목표</strong> :  Neo는 블록체인 기술과 디지털 ID를 사용하여 자산을 디지털화하고, 디지털 자산에 대한 스마트 계약을 사용하여 자체 관리하고, 분산 네트워크를 통해 “스마트 경제”를 달성</p></blockquote><br/><h3 id="📟-알고리즘-및-특징"><a href="#📟-알고리즘-및-특징" class="headerlink" title="📟  알고리즘 및 특징"></a>📟  알고리즘 및 특징</h3><p>✅  <strong>합의 메커니즘 : dBFT</strong></p><p>위임된 비잔틴 장애 허용(Delegated Byzantine Fault Tolerant)는 대리 투표를 통해 대규모 합의 참여를 가능하게 하는 비잔틴 장애 허용 합의 메커니즘. </p><p>NEO 토큰 보유자는 투표를 통해 지지하는 합의 노드를 선택할 수 있음. 선택된 합의 노드 그룹은 BFT 알고리즘을 통해 합의에 도달하고 새로운 블록을 생성. 투표는 정해진 기간이 아닌 실시간으로 진행.</p><p>dBFT는 n개의 합의 노드로 구성된 합의 시스템에 대해 f &#x3D; ⌊(n-1) &#x2F; 3 ⌋의 내결함성을 제공. 이 내결함성에는 보안과 가용성이 모두 포함되며 일반 및 비잔틴 장애에 대한 내성이 있으며 모든 네트워크 환경에 적합. <strong>dBFT는 최종 확인이 완료되면 블록을 분기할 수 없으며 트랜잭션이 취소되거나 롤백되지 않음.</strong></p><p>블록 생성에는 약 15~20초가 소요되며 트랜잭션 처리량은 최대 약 <strong>1,000TPS</strong>까지 측정되며, 이는 퍼블릭 체인 중 우수한 성능. 적절한 최적화를 통해 10,000TPS에 도달할 가능성 있음.</p><p>dBFT는 디지털 신원 기술을 결합하여 합의 노드가 개인 또는 기관의 실명이 될 수 있음을 의미. 따라서 법원의 결정에 따라 동결, 취소, 상속, 회수 및 소유권 이전이 가능. 이를 통해 Neo 네트워크에 규정 준수 금융 자산을 쉽게 등록할 수 있음.</p><p>+ <a href="http://wiki.hash.kr/index.php/%EB%85%B8%EB%93%9C">노드</a>를 운영하는 <a href="http://wiki.hash.kr/index.php/%EB%B6%81%ED%82%A4%ED%8D%BC">북키퍼</a>(Book Keeper)의 60% 이상이 동의할 경우에만 합의가 이루어지는 방식이다. 이를 위해 먼저 네오 코인 사용자들은 투표를 통해서 대표자인 북키퍼를 선출한다. 위임 프랙티컬 비잔틴 장애 허용(dPBFT) 방식을 통해 선출된 북키퍼들은 <a href="http://wiki.hash.kr/index.php/%EB%B8%94%EB%A1%9D">블록</a>을 검증할 때마다 <a href="http://wiki.hash.kr/index.php/%EB%9E%9C%EB%8D%A4">랜덤</a>으로 그 중에서 다시 블록 생성자(BP)들이 결정되고, 이 중 3분의 2 이상의 북키퍼들이 검증에 동의하여 합의가 이루어지면, 새로운 블록이 생성된다.</p><p><img src="https://steemitimages.com/1280x0/https://cdn.steemitimages.com/DQmUtTsfhb11ENwwvfifL5b1QFqmmeL88RSgwAzqJQoLA6L/Screen%20Shot%202018-05-26%20at%204.52.13%20PM.png"></p><p><img src="https://user-images.githubusercontent.com/99964401/201851001-b1c7f44d-3a86-49fe-8fd1-d12327705d20.png"></p><br/><h3 id="✏️-네오를-선택한-이유"><a href="#✏️-네오를-선택한-이유" class="headerlink" title="✏️ 네오를 선택한 이유"></a>✏️ 네오를 선택한 이유</h3><p>네오는 2015년 출시된 중국 최초의 블록체인으로, 독자적인 스마트 컨트랙트 기술인 네오 컨트랙트를 기반으로 중국에 이더리움이라 불릴만큼 이더리움과 비슷한 가능(SC, Dapp등)을 제공합니다. 향후 중국의 암호화폐에 대한 규제가 풀리게되면 더욱 각광받을 암호화폐라고 생각합니다. </p><p>또한, 이더리움 처럼 가상 머신(VM)에서 실행되지만 개발자들이 쉽게 개발 하기 위해 독자적인 VM을 통해 C, Java, Go, Python, JS등 다양한 개발 언어를 지원하기 때문에 다양한 개발 언어를 사용하는 우리 팀이 개발을 진행하기에 언어 선택의 폭이 넓을 것이라 생각했습니다.</p><p>마지막으로 Neo에서는 계정의 종류로 normal 뿐아니라 다중서명 계정 (multisig) 또한 제공하여 이론으로만 접했던 multisig account를 통한 트랜잭션 생성 및 서명, 전송등의 enhancement 기능을 저희 프로젝트에 녹여낼 수 있을 것이라 생각하여 선택 하게 되었습니다.</p> <br/><h2 id="프로젝트-상세"><a href="#프로젝트-상세" class="headerlink" title="프로젝트 상세"></a>프로젝트 상세</h2><h3 id="0"><a href="#0" class="headerlink" title="0."></a>0.</h3><p><strong>팀명</strong> : <strong>(빗)썸 타고싶다.</strong></p><p><strong>개발 프로젝트명</strong> : <strong>빗썸</strong>이 다가오<strong>네오</strong> (<strong>bithumb</strong> Dagao <strong>Neo</strong>)</p><br/><h3 id="I-개요"><a href="#I-개요" class="headerlink" title="I. 개요"></a>I. 개요</h3><p>빗썸이 다가오네오(bithumb Dagao Neo) 프로젝트는 네오(NEO) 블록체인에 대한 1.프라이빗 네트워크를 구축하고 이 네트워크 상의 2.Block, Tx, Acccount 기록을 탐색 할 수 있는 웹기반 익스플로어,  3. normal, multisig 계정을 생성하고 프라이빗 네트워크에 트랜잭션을 전송할 수 있는 크롬 익스텐션 기반의 지갑을 제공 합니다. </p><br/><h3 id="II-기술-스텍"><a href="#II-기술-스텍" class="headerlink" title="II. 기술 스텍"></a>II. 기술 스텍</h3><ol><li><p><strong>노드, Daemon, API</strong></p><p> Docker, Mongo DB, Python</p></li><li><p><strong>Wallet</strong></p><p> MUI, NeonJs, CSS, React, Crypto, Ethers, Chrome Extension, Axios</p></li><li><p><strong>Explorer</strong></p><p> Axios, AntDesign, React, NeonJs, NodeJs</p></li></ol><br/><h3 id="III-핵심기능"><a href="#III-핵심기능" class="headerlink" title="III. 핵심기능"></a>III. 핵심기능</h3><p><strong>[</strong> <strong>지갑 ]</strong></p><ul><li>지갑 생성</li><li>로그인</li><li>토큰 전송</li><li>MultiSig Account 생성</li><li>MultiSig Account를 통한 트랜잭션 생성, 서명, 전송 및 디스코드 메시지 전송</li></ul><p><strong>[ 익스플로어 ]</strong></p><ul><li>현재 노드의 상태를 통합하여 보여주는 Overview</li><li>트랜잭션 조회</li><li>블록 조회</li><li>Address 조회 (잔고, NEP17 토큰 거래 내역 리스트 조회)</li><li>검색창에서 Tx, Block number, Addres 검색 기능</li></ul><p><strong>[ 노드 ]</strong></p><ul><li>블록 생성용(1Consensus) + 블록 검증용 (2 Client) (dBFT) 구성</li><li>RPC 호출, DB동기화</li><li>Rest API 제공</li></ul><br/><h3 id="IV-차별점"><a href="#IV-차별점" class="headerlink" title="IV.차별점"></a>IV.차별점</h3><ul><li>[Wallet] 크롬 익스텐션 개발 , 실제 제품과 유사한 기능</li><li>[Wallet] 니모닉 코드로 계정 복구</li><li>[Wallet] MultiSig Account 생성, Tx생성, 서명, 전송과 디스코드 메시지 전송 기능</li><li>[Explorer] Tx, Block number, address로 검색할 수 있는 Search Box</li><li>[Explorer] Restfull API를 사용하여 빠른 반응성</li></ul><br/><h2 id="프로젝트-상세-1"><a href="#프로젝트-상세-1" class="headerlink" title="프로젝트 상세"></a>프로젝트 상세</h2><h2 id="01-지갑-Wallet"><a href="#01-지갑-Wallet" class="headerlink" title="01. 지갑(Wallet)"></a>01. 지갑(Wallet)</h2><p><code>빗썸이 다가오네오</code> 지갑은 프라이빗 노드에 대한 지갑 관리를 지원하는 크롬 익스텐션 기반 소프트웨어 지갑입니다. 이 지갑은 중앙 서버의 통제 없이 사용자 지갑 정보를 로컬에서 관리할 수 있도록 설계되어 중앙화된 서버에 대한 공격으로부터 자유롭고, 다중 서명 계정을 지원하며 다중 서명 계정에 대한 모든 동작을 디스코드 메시지로 다른 소유자들과 공유 할 수 있습니다.</p><ol><li><strong>보안</strong></li></ol><p>지갑 생성시 니모닉 구문이 발급되고 해당 니모닉 구문으로 지갑을 복구 할 수 있습니다. Neo의 계정에 대한 다양한 키들에 대한 상호관계와 Hierarchy는 아래 그림과 같습니다. ↔ 는 서로를 유도해 낼수 있는 관계를 의미하며(동등한 계급을 의미), ⬇️는 단방향으로의 유도는 가능하나 그 역으로 유도하는것은 불가한 관계를 의미합니다.</p><p><img src="https://user-images.githubusercontent.com/99964401/201851266-29234212-8d07-47fa-80ca-d05a20bad893.png"></p><p>(NEP2*는 NEP2 standard에서 정의된 NEO만의 새로운 Key로 그 지위는 다른 암호화폐에도 흔히 사용되는 WIF, PrivateKey와 동등한 위치를 가집니다.)</p><p>저희 지갑은 어카운트의 다양한 키 들을 로컬에 직접적으로 저장하지 않고 encrypt된 형태로 저장하여 보안적 측면을 강화 하였습니다.</p><br/><h3 id="🪙-특별한-기능"><a href="#🪙-특별한-기능" class="headerlink" title="🪙 특별한 기능"></a>🪙 <strong>특별한 기능</strong></h3><p>**다중 서명 계정 (multi-signature account)**는 **여러개의 공개키 (Pubkey)**로 구성된 주소로, 이 주소에서 자산을 이전 하려면 한명 이상의 당사자가 서명 해야합니다. 아래 그림은 m &#x2F; n 다중 서명 주소의 구조를 나타냅니다.</p><p>이러한 다중서명 방식은 한명이 비밀키 보관에 실패하게 되어도 다른 사람들의 서명이 없으면 자산을 옮길 수 없게 하여 자산의 안전한 보관에 용이하며, 공동의 재산을 관리 할 때 한사람이 횡령하는 경우를 방지할 수 있고, 2명간의 거래 사이에 중재자로 제3자인 서비스 제공자가 함께 다중 서명 계정을 만듬으로서 블록체인을 활용한 안전 거래에도 활용 될 수 있습니다. </p><p>(많은 투자자들의 거금이 운용되는 암호화폐 거래소에서의 활용은 두말 할것도 없겠쥬🤣)</p><p>네오의 다중 서명 계정도 2~16명의 pubkey를 이용하여 생성 할 수 있으며, 서명 순서는 다중 서명 계정을 만들때 공개키의 입력 순서와는 무관하여도 됩니다.</p><p><img src="https://user-images.githubusercontent.com/99964401/201851324-e3b7e68d-9e7d-4f50-a526-8a1f8dac8e7d.png"></p><p>(다중 서명 계정에 대한 추가 이론적 스터디는 다음 <a href="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3cdd03ab-1f99-4646-bb4a-293e9e8a3d7c/Multi_sig_p2sh_script.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45/20221114/us-west-2/s3/aws4_request&X-Amz-Date=20221114T035814Z&X-Amz-Expires=86400&X-Amz-Signature=93cea65eb5b6314ee66f55717c9d488e4b3d5f5d854fc9cda0d5b725c3dcc2c2&X-Amz-SignedHeaders=host&response-content-disposition=filename=%22Multi%2520sig%252C%2520p2sh%2520script.pdf%22&x-id=GetObject">링크</a>에서 찾아 보실 수 있습니다.)</p><p>저희 <code>빗썸이 다가오네오</code> 지갑에서는 노멀 계정 뿐아니라 다중 서명 계정 또한 쉽게 생성 할 수 있고, 생성 사실을 공개키의 주인들과 디스코드 채널 메시지를 통해 바로 공유할 수 있습니다.</p><p>또한 다중 서명 계정을 통한 송금 트랜잭션 생성도 일반 계정의 송금 트랜잭션 생성만큼 간편하며, 이 또한 디스코드 채널을 통해 공유됩니다. 해당 메시지를 받은 다른 멤버들도 메시지에 포함된 인코딩된 Tx을 입력하여 자신의 서명을 추가 할 수 있고, 서명 여부를 디스코드 채널을 통해 공유할 수 있습니다. 이렇게 m 명중 n명의 서명이 완료 되면 지갑을 통해 해당 트랜잭션을 send할 수 있습니다.</p><br/><h3 id="🖥️-기능별-설명-및-동작-GIF"><a href="#🖥️-기능별-설명-및-동작-GIF" class="headerlink" title="🖥️ 기능별 설명 및 동작 GIF"></a>🖥️ <strong>기능별 설명 및 동작 GIF</strong></h3><ul><li><p><strong>지갑 생성 및 니모닉 구문 발급</strong></p><ol><li>지갑 생성</li></ol><ul><li><p><code>니모닉 구문</code>을 통한 HDWallet 생성</p><ul><li><code>니모닉 구문</code>을 사용하여 <code>private key</code> 생성</li></ul>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">&#x27;ethers&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mnemonicCode = ethers.<span class="property">utils</span>.<span class="title function_">entropyToMnemonic</span>(ethers.<span class="property">utils</span>.<span class="title function_">randomBytes</span>(<span class="number">16</span>));</span><br></pre></td></tr></table></figure></li><li><p>Neo Account 생성</p><ul><li><code>니모닉 구문</code>으로 생성된 <code>private key</code>를 사용하여 Neo 계정을 생성한다. (주소를 발급)</li></ul>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wallet <span class="keyword">from</span> <span class="string">&quot;@cityofzion/neon-js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">&#x27;ethers&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPrivateKeyFromMnemonic</span> = (<span class="params">mnemonicCode</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> mnemonicWallet = ethers.<span class="property">utils</span>.<span class="property">HDNode</span>.<span class="title function_">fromMnemonic</span>(mnemonicCode);</span><br><span class="line">    <span class="keyword">const</span> privateKey = mnemonicWallet.<span class="property">privateKey</span>.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> privateKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="title function_">getPrivateKeyFromMnemonic</span>(mnemonicCode);</span><br><span class="line"><span class="keyword">const</span> userAccount = <span class="keyword">new</span> wallet.<span class="title class_">Account</span>(privateKey);</span><br></pre></td></tr></table></figure></li><li><p>생성된 계정을 <code>encryption</code>하여 <code>local storage</code>에 저장</p><ul><li><code>private key</code>는 사용자가 입력한 <code>password</code>를 사용하여 <code>encryption</code>된다.</li></ul></li></ul><p>  <strong>[로그인 방식 수정 후]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201851915-a7e239b2-a92a-48b3-a5a0-1aa8d1c40456.gif" alt="CreateNeoWallet"></p></li><li><p><strong>로그인</strong></p><ul><li>사용자가 <code>password</code>를 입력하여 로그인<ul><li>입력된 <code>password</code>는 암호화된 <code>private key</code>를 <code>decryption</code> 하는 데에 사용된다.</li></ul></li></ul><p>  <strong>[로그인 방식 수정 후]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201851945-900e783b-652b-4dbf-8cd9-ef03523406b8.gif" alt="LoginNeoWallet">  </p></li><li><p><strong>지갑 복구</strong></p><ul><li><code>니모닉 구문</code>을 사용하여 <code>private key</code>를 생성할 때 결과는 <code>deterministic</code>하다. 즉, 동일한 <code>니모닉 구문</code>을 입력값으로 받을 시, 매번 동일한 <code>private key</code>가 생성된다.</li><li>따라서, 암호을 까먹어 더 이상 <code>private key</code>를 <code>decrypt</code>할 수 없는 경우, 초기 지갑 생성시에 발급받은 <code>니모닉 구문</code>을 사용하여 동일한 <code>private key</code>를 받을 수 있다.</li><li>다시 발급 받은 <code>private key</code> 를 <code>새로운 비밀번호</code>로 <code>encryption</code>한다.</li><li>추후, 이 <code>새로운 비밀번호</code>를 사용하여 <code>decrpyion</code> 할 수 있다.</li></ul>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">restoreAccount</span> = <span class="keyword">async</span>(<span class="params">encryptedAccount, mnemonicCode, newPassword</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> privateKey = <span class="title function_">getPrivateKeyFromMnemonic</span>(mnemonicCode);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: encryptedAccount.<span class="property">address</span>,</span><br><span class="line">        <span class="string">&quot;publicKey&quot;</span>: encryptedAccount.<span class="property">publicKey</span>,</span><br><span class="line">        <span class="string">&quot;privateKey&quot;</span>: <span class="keyword">await</span> <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(privateKey, newPassword),</span><br><span class="line">        <span class="string">&quot;scriptHash&quot;</span>: encryptedAccount.<span class="property">scriptHash</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>지갑 로그아웃 및 초기화</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201851982-149a9c85-beaf-4d72-8565-30332e9ef029.gif" alt="NeoLogout InitWallet"></p></li><li><p><strong>계정 NEO, GAS 토큰 밸런스 확인</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201852404-6dc16523-080a-42e9-8f7e-5e815299ab96.gif" alt="CheckBalanceNeoWallet"></p></li><li><p><strong>토큰 전송</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201852190-38abe535-06dd-4e1b-82a2-07d03cdc1974.gif" alt="NeoTransfer"></p><ul><li><p><strong>데이터 처리 방식 수정 전 Transfer</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/201852277-a7e2e8e1-2340-40e9-a021-d0ce6a536d79.gif" alt="Transfer"></p></li><li><p><code>script</code>는 어떤 <code>주소</code>(toAddress)로 <code>어떤 토큰</code>(tokenHash)이 <code>얼마 만큼</code>(tokenAmount) 보내질지 정의되어 있다.</p></li><li><p>로그인 과정을 거쳐 <code>userAccount</code>에는 <code>decrpytion</code>된 <code>private key</code> 정보가 들어가 있다.</p></li><li><p><code>script</code>와 사용자의 <code>sign</code>이 들어간 <code>transaction</code>을 완성시킬 수 있다.</p></li></ul>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> script = sc.<span class="title function_">createScript</span>(&#123;</span><br><span class="line"><span class="attr">scriptHash</span>: tokenHash,</span><br><span class="line"><span class="attr">operation</span>: <span class="string">&quot;transfer&quot;</span>,</span><br><span class="line"><span class="attr">args</span>: [sc.<span class="property">ContractParam</span>.<span class="title function_">hash160</span>(userAccount.<span class="property">address</span>), </span><br><span class="line"> sc.<span class="property">ContractParam</span>.<span class="title function_">hash160</span>(toAddress), </span><br><span class="line"> sc.<span class="property">ContractParam</span>.<span class="title function_">integer</span>(tokenAmount),</span><br><span class="line"> sc.<span class="property">ContractParam</span>.<span class="title function_">any</span>()],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myTx = <span class="keyword">new</span> tx.<span class="title class_">Transaction</span>(&#123;</span><br><span class="line">        <span class="attr">signers</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">account</span>: userAccount.<span class="property">scriptHash</span>,</span><br><span class="line">                <span class="attr">scopes</span>: tx.<span class="property">WitnessScope</span>.<span class="property">CalledByEntry</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">validUntilBlock</span>: currentHeight + heightIncrease,</span><br><span class="line">        <span class="attr">systemFee</span>: systemFee,</span><br><span class="line">        <span class="attr">networkFee</span>: networkFee,</span><br><span class="line">        script,</span><br><span class="line">    &#125;).<span class="title function_">sign</span>(userAccount, networkMagic, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>멀티시그 어카운트 생성</strong></p><p>  다중 서명 계정을 만들고자 하는 사람들의 Pubkey를 입력하고, 해당 계정에서 발생한 트랜잭션에 몇명이상 서명을 해야 트랜잭션이 전송될지 결정하는 sining threshold수를 선택합니다. 서명메시지를 보낼 디스코드 webHook 링크를 입력합니다. +,- 버튼을 눌러 입력란을 늘리고 삭제 할 수 있습니다. 다중 서명 계정을 만들수 있는 최소 공개키 갯수는 2명입니다.</p><p>  결과 디스코드 메시지</p></li><li><p><strong>멀티시그 트랜잭션 생성</strong></p><p>  다중 서명 계정을 통한 트랜잭션 생선은 MultiSig Transfer버튼을 누르고 일반 송금과 같은 정보를 입력합니다. 지갑 UI에서 보이는 동작은 일반 전송과 비슷해 보이나, 뒤에서는 다중 서명 계정으로 생성된 트랜잭션에 트랜잭션 생성한 사람의 서명이 들어가고 이것을 serialize후 bs58로 인코딩하여 길이를 최대한 줄입니다. 그후 이 값을 입력한 webHook link에 해당하는 채널로 트랜잭션 정보와 메시지로 전송합니다.</p></li><li><p><strong>멀티시그 트랜잭션 서명</strong></p><p>  메시지를 받은 사람은 생성된 트랜잭션에 자신의 서명을 추가하기 위해 get multisig tx버튼을 눌러 서명을 추가하는 페이지로 이동 합니다. 첫번째 입력란에 encoding된 Tx을 입력하고 두번째 입력란에 메시지를 받을 디스코드 채널의 URL을 입력한뒤 서명하기 버튼을 누릅니다.</p><p>  그러면 인코딩된 트랜잭션을 디코딩 → deserialize를 거쳐 다시 서명 할 수 있는 트랜잭션 class로 복원하고 여기에 해당 계정의 서명을 더한후 다시 인코딩 → serialize 과정을 거쳐 이값을 메시지로 보냅니다.</p></li><li><p><strong>멀티시그 트랜잭션 전송</strong></p><p>  threshold 이상의 참가자가 서명한 트랜잭션은 마찬가지로 get Multisig Tx 페이지에서 전송할 수 있습니다.</p></li></ul><br/><h2 id="02-탐색기-Explorer"><a href="#02-탐색기-Explorer" class="headerlink" title="02. 탐색기(Explorer)"></a>02. 탐색기(Explorer)</h2><p><code>빗썸이 다가오네오</code> 탐색기는 프라이빗 노드에 대한 Block, Tx, Address 조회를 지원하는 웹 페이지 기반 탐색기 입니다. 프라이빗 노드에 주기적으로 접근하여 업데이트 되는 DB로 부터 Rest API를 통해 정보들을 가져오기 때문에 속도가 빠르며 누구나 쉽게 조회 할 수 있도록 설계 되었습니다.</p><br/><h3 id="🪙-특별한-기능-1"><a href="#🪙-특별한-기능-1" class="headerlink" title="🪙  특별한 기능"></a>🪙  <strong>특별한 기능</strong></h3><ul><li><strong>Search Box</strong> : Neon Js의 Verify 기능과 자체적으로 구축한 verify기능으로 입력값의 format이 유효한지 확인하고 해당 입력값이 Tx hash, Block number, Neo Address인지 구분하여 상세페이지로 이동하게 해줍니다. 유효하지  않은 입력값은 Alert로 알려줍니다.</li><li><strong>Address Detail</strong> : 잔고 조회 뿐 아니라, 해당 Address의 모든 NEP17 토큰(네오, 가스 포함)의 거래 내역을 송신, 발신 구분하여 리스트로 확인 할 수 있습니다.</li></ul><br/><h3 id="🖥️-기능-설명-및-동작-GIF"><a href="#🖥️-기능-설명-및-동작-GIF" class="headerlink" title="🖥️ 기능 설명 및 동작 GIF"></a>🖥️ <strong>기능 설명 및 동작 GIF</strong></h3><ul><li><p><strong>블록 조회</strong></p></li><li><p><strong>트랜잭션 조회</strong></p></li><li><p><strong>계정 조회</strong></p><p>  private network에 정상적으로 트랜잭션을 send한적 있는 모든 계정 주소를 확인 할 수 있습니다. 뿐만아니라 상세 페이지에서 해당 계정을 통해 주고 받은 neo와 gas의 거래 기록을 확인 할 수 있습니다.</p></li><li><p><strong>검색</strong></p><p>  Neon Js의 Verify 기능과 자체적으로 구축한 verify기능으로 입력값의 format이 유효한지 확인하고 해당 입력값이 Tx hash, Block number, Neo Address인지 구분하여 상세페이지로 이동하게 해줍니다.</p></li></ul><br/><h3 id="03-프라이빗-노드-및-데몬-Node-amp-Daemon"><a href="#03-프라이빗-노드-및-데몬-Node-amp-Daemon" class="headerlink" title="03. 프라이빗 노드 및 데몬 (Node &amp; Daemon)"></a>03. 프라이빗 노드 및 데몬 (Node &amp; Daemon)</h3><p>Neo Private Node는 Legacy다음에 새로 업데이트된 최신 버전인 NEO3에 대한 것으로, dPBFT합의 알고리즘을 사용하는 Neo의 특성을 고려하여 블록을 생성하는 1개의 Consenses 노드와 블록을 검증 하는 2개의 Client 노드로 이루어져 있습니다. 또한 외부와 원할한 RPC 소통을 하기위한 RPC 플러그인과 NEP17, NEP11 토큰을 추적하기 위해 활용되는 플러그인이 설치 되어있습니다.</p><p>데몬 프로그램은  JSON-RPC 기반의 API를 통해서 블록과 트랜잭션 정보들을 DB에 동기화 하는 프로그램 입니다. Python + MongoDB로 구성되어 있으며 Docker Runtime으로 구동합니다. 데몬 구현은 Python의 스케쥴러를 활용하였고, 주기적으로 Block 생성을 담당하는 Consensus 노드의 블록을 15초 (1 블록이 생성되는 평균 시간)마다 확인하여  블록정보,트랜잭션, 계좌잔고, 이체 이력을 MongoDB에 동기화 합니다.</p><p>데이터베이스의 정보를 가공하여 블록탐색기에서 블록체인 정보를 쉽고 빠르게 조회 할수 있도록 블록정보,트랜잭션 정보 및 이체기록에 관한 REST API를 제공합니다.  </p><br/><h2 id="Problem-amp-Solution-팀원별"><a href="#Problem-amp-Solution-팀원별" class="headerlink" title="Problem &amp; Solution (팀원별)"></a>Problem &amp; Solution (팀원별)</h2><ul><li><p><strong>Multisig</strong></p><p>  멀티시그의 원리를 이해 하고, neon js를 통해 멀티시그 계정을 생성하고 트랜잭션을 보내는데까지도 어려움이 있었지만, 중앙 서버가 없는 저희 지갑이 어떤 방식으로 다중 서명을 하기위해 다른 사용자와 연락을 할수 있을지에 대해 아이디어 적인 고민이 많았습니다. 결과적으로 트랜잭션을 serialize → bs58을 통한 encoding을 생각하게 되었고, 이것으로부터 서명, 트랜잭션 전송을 하기위해 역과정을 거쳐 트랜잭션을 neon js의 transaction class로 복원하는데 성공 하였습니다. 또한 블록체인을 활용하는 사람들이 자주 사용하는 연락 방법인 디스코드를 통해 이를 전송하고, 지갑 사용자들이 어렵지 않게 다중서명 계정을 이용할 수 있도록 UI를 간소화 시켜 해당 기능을 완성 할 수 있었습니다.</p></li><li><p><strong>NODE</strong></p><p>  Neo 현재 Neo Legacy와 Neo N3 로 이름은 Neo 지만 호환되지 않은 프로토콜을 가지고 있어 스터디 초반 검색되어 지는 소스 및 문서가 어떤것인  Legacy 이며 N3인지 시행착오를 거쳐야 했습니다. 다행이 각각 버전 별로 다른 지갑주소를 생성하것을 알게 되어 최신 N3 프로토콜에 맞춰 프로젝트를 진행할수 있었습니다.</p></li><li><p><strong>OS&#x2F;Package dependency</strong></p><ul><li>Problem: Private node 도커 환경 및 개발 툴이 특정 OS와 특정 버전에서만 지원하는 경우가 많았습니다. Neo는 애초에 윈도우&#x2F;C#에 친화적으로 만들어졌고, 개발에 필요한 툴들 및 패키지들이 특정 OS에 의존성이 있어 시행착오가 많았습니다.</li><li>Solution: Private Node를 Ubuntu 환경에서 문제 없이 돌리도록 하였고, 윈도우에서만 돌아가는 Neo-GUI를 사용하지 않고도 빠르게 테스트 해볼 수 있도록, 테스트 케이스들을 우선적으로 작성하고 정리하는 작업을 거쳤습니다. 첫 한 주에 편한 개발 환경을 만들기 위한 리서치와 환경을 구성하는 데에 많은 시간을 소모하였지만, 사전에 이러한 어려운 작업들을 미리 준비하고 끝내놓은 덕분에 잘 마무리 할 수 있었습니다.</li></ul></li><li><p><strong>Encryption, decryption, 그리고 니모닉</strong></p><ul><li>“ <code>니모닉 구문</code>으로 <code>비밀번호를 재설정</code> 할 수 있다.” 일반 월렛 툴만을 사용하는 사용자 입장에서 또한 인터넷 상의 글을 통해서 실제로 저런 것이 어떻게 이루어지는지 이해하는 데에 어려움이 있었고, 완벽히 이해하기까지 꽤 많은 시간이 걸렸습니다. 지갑 생성을 위한 여러 라이브러리를 참고하고 연구하고 테스트해보며, 어떤 것이 <code>encryption</code>되고 <code>decryption</code> 되어야 하는지, 또 어떤 과정을 거쳐서 이루어 지는지, 이러한 과정들이 물 흐르듯 자연스럽게 이루어 지려면 각 기능의 input과 output은 어떻게 되어야는지에 대한 고민을 많이 해볼 수 있었습니다.<ul><li><code>private key</code> 및 <code>private key</code>를 알아낼 수 있는 모든 정보(<code>니모닉 코드</code>)는 암호화되지 않은 (<code>decrypted</code>) 상태에서 local storage에 <code>저장해서는 안된다</code>.</li><li><code>동일한 니모닉 구문</code>을 사용하면 <code>매번 같은 private key</code>를 생성할 수 있다.</li><li><code>비밀번호</code>를 통해 <code>private key</code>를 <code>encryption</code>&#x2F;<code>decryption</code> 할 수 있다.</li></ul></li><li>이 세 가지가 이해된 뒤, 더 간단하고 알아보기 쉬운 코드로 구현할 수 있었고, 내가 헷갈리고 헤맨 부분을 더 집중하여 문서를 작성하였습니다.</li><li>“<code>니모닉 구문</code>으로 <code>비밀번호를 재설정</code>할 수 있다.” ⇒ “<code>동일한 니모닉 코드</code>로 <code>동일한 private key를 생성</code>할 수 있고, 내가 입력한 <code>비밀번호</code>로 <code>encryption</code>된 <code>private key</code>는 똑같이 <code>비밀번호</code>로 <code>decryption</code>할 수 있다.”</li></ul></li><li><p><strong>Wallet User Data 저장</strong></p><ul><li>사용자가 본인 소유의 자산을 직접적으로 관리하는 지갑이 익스텐션 wallet의 목표이기 때문에, 로컬에 저장하는 방식이라도 어떤 데이터를 저장하여 관리할지 팀원들과 고민을 많이 했다.</li><li>구현 초기에는 Create Wallet 이후 생성된 사용자의 Wallet password, Mnemonic, Privatekey, Publickey, Address 등의 정보를 모두 Chrome Storage에 저장하였고, 이후 수정을 걸쳐 암호화된 소수의 정보들만 저장을 하였다.</li></ul></li></ul><br/><hr><h2 id="03-프라이빗-노드-및-데몬-Node-amp-Daemon-1"><a href="#03-프라이빗-노드-및-데몬-Node-amp-Daemon-1" class="headerlink" title="03. 프라이빗 노드 및 데몬 (Node &amp; Daemon)"></a>03. 프라이빗 노드 및 데몬 (Node &amp; Daemon)</h2><h3 id="Neo-Private-Node"><a href="#Neo-Private-Node" class="headerlink" title="Neo Private Node"></a><strong>Neo Private Node</strong></h3><blockquote><p><strong>Neo Private Node</strong>는 Legacy다음에 새로 업데이트된 최신 버전인 <strong>NEO3</strong>에 대한 것으로, <strong>dPBFT 합의 알고리즘을 사용</strong>하는 Neo의 특성을 고려하여 <strong>블록을 생성하는 1개의 Consenses 노드</strong>와 <strong>블록을 검증 하는 2개의 Client 노드</strong>로 이루어져 있습니다. 또한 외부와 원할한 <strong>RPC 소통을 하기위한 RPC 플러그인</strong>과 <strong>NEP17, NEP11 토큰을 추적하기 위해 활용되는 플러그인</strong>이 설치 되어있습니다.</p></blockquote><br/><h3 id="데몬"><a href="#데몬" class="headerlink" title="데몬"></a>데몬</h3><blockquote><p><strong>데몬 프로그램</strong>은  <strong>JSON-RPC 기반의 API</strong>를 통해서 <strong>블록과 트랜잭션 정보들을 DB에 동기화</strong> 하는 프로그램 입니다. Python + MongoDB로 구성되어 있으며 <strong>Docker Runtime으로 구동</strong>합니다. 데몬 구현은 Python의 스케쥴러를 활용하였고, 주기적으로 <strong>Block 생성을 담당하는 Consensus 노드의 블록을 15초</strong> (1 블록이 생성되는 평균 시간)마다 확인하여  <strong>블록정보, 트랜잭션, 계좌잔고, 이체 이력을 MongoDB에 동기화</strong> 합니다.</p><p>데이터베이스의 정보를 가공하여 <strong>블록탐색기에서 블록체인 정보를 쉽고 빠르게 조회</strong> 할수 있도록 <strong>블록정보, 트랜잭션 정보 및 이체기록에 관한 REST API를 제공</strong>합니다.  </p></blockquote><br/><hr><h2 id="4-Problem-amp-Solution-팀원별"><a href="#4-Problem-amp-Solution-팀원별" class="headerlink" title="4. Problem &amp; Solution (팀원별)"></a>4. Problem &amp; Solution (팀원별)</h2><ul><li><p><strong>Multisig</strong></p><p>  멀티시그의 원리를 이해 하고, neon js를 통해 멀티시그 계정을 생성하고 트랜잭션을 보내는데까지도 어려움이 있었지만, 중앙 서버가 없는 저희 지갑이 어떤 방식으로 다중 서명을 하기위해 다른 사용자와 연락을 할수 있을지에 대해 아이디어 적인 고민이 많았습니다. 결과적으로 트랜잭션을 serialize → bs58을 통한 encoding을 생각하게 되었고, 이것으로부터 서명, 트랜잭션 전송을 하기위해 역과정을 거쳐 트랜잭션을 neon js의 transaction class로 복원하는데 성공 하였습니다. 또한 블록체인을 활용하는 사람들이 자주 사용하는 연락 방법인 디스코드를 통해 이를 전송하고, 지갑 사용자들이 어렵지 않게 다중서명 계정을 이용할 수 있도록 UI를 간소화 시켜 해당 기능을 완성 할 수 있었습니다.</p></li><li><p><strong>NODE</strong></p><p>  Neo 현재 Neo Legacy와 Neo N3 로 이름은 Neo 지만 호환되지 않은 프로토콜을 가지고 있어 스터디 초반 검색되어 지는 소스 및 문서가 어떤것인  Legacy 이며 N3인지 시행착오를 거쳐야 했습니다. 다행이 각각 버전 별로 다른 지갑주소를 생성하것을 알게 되어 최신 N3 프로토콜에 맞춰 프로젝트를 진행할수 있었습니다.</p></li><li><p><strong>OS&#x2F;Package dependency</strong></p><ul><li>Problem: Private node 도커 환경 및 개발 툴이 특정 OS와 특정 버전에서만 지원하는 경우가 많았습니다. Neo는 애초에 윈도우&#x2F;C#에 친화적으로 만들어졌고, 개발에 필요한 툴들 및 패키지들이 특정 OS에 의존성이 있어 시행착오가 많았습니다.</li><li>Solution: Private Node를 Ubuntu 환경에서 문제 없이 돌리도록 하였고, 윈도우에서만 돌아가는 Neo-GUI를 사용하지 않고도 빠르게 테스트 해볼 수 있도록, 테스트 케이스들을 우선적으로 작성하고 정리하는 작업을 거쳤습니다. 첫 한 주에 편한 개발 환경을 만들기 위한 리서치와 환경을 구성하는 데에 많은 시간을 소모하였지만, 사전에 이러한 어려운 작업들을 미리 준비하고 끝내놓은 덕분에 잘 마무리 할 수 있었습니다.</li></ul></li><li><p><strong>Encryption, decryption, 그리고 니모닉</strong></p><ul><li>“ <code>니모닉 구문</code>으로 <code>비밀번호를 재설정</code> 할 수 있다.” 일반 월렛 툴만을 사용하는 사용자 입장에서 또한 인터넷 상의 글을 통해서 실제로 저런 것이 어떻게 이루어지는지 이해하는 데에 어려움이 있었고, 완벽히 이해하기까지 꽤 많은 시간이 걸렸습니다. 지갑 생성을 위한 여러 라이브러리를 참고하고 연구하고 테스트해보며, 어떤 것이 <code>encryption</code>되고 <code>decryption</code> 되어야 하는지, 또 어떤 과정을 거쳐서 이루어 지는지, 이러한 과정들이 물 흐르듯 자연스럽게 이루어 지려면 각 기능의 input과 output은 어떻게 되어야는지에 대한 고민을 많이 해볼 수 있었습니다.<ul><li><code>private key</code> 및 <code>private key</code>를 알아낼 수 있는 모든 정보(<code>니모닉 코드</code>)는 암호화되지 않은 (<code>decrypted</code>) 상태에서 local storage에 <code>저장해서는 안된다</code>.</li><li><code>동일한 니모닉 구문</code>을 사용하면 <code>매번 같은 private key</code>를 생성할 수 있다.</li><li><code>비밀번호</code>를 통해 <code>private key</code>를 <code>encryption</code>&#x2F;<code>decryption</code> 할 수 있다.</li></ul></li><li>이 세 가지가 이해된 뒤, 더 간단하고 알아보기 쉬운 코드로 구현할 수 있었고, 내가 헷갈리고 헤맨 부분을 더 집중하여 문서를 작성하였습니다.</li><li>“<code>니모닉 구문</code>으로 <code>비밀번호를 재설정</code>할 수 있다.” ⇒ “<code>동일한 니모닉 코드</code>로 <code>동일한 private key를 생성</code>할 수 있고, 내가 입력한 <code>비밀번호</code>로 <code>encryption</code>된 <code>private key</code>는 똑같이 <code>비밀번호</code>로 <code>decryption</code>할 수 있다.”</li></ul></li><li><p><strong>Wallet User Data 저장</strong></p><ul><li>사용자가 본인 소유의 자산을 직접적으로 관리하는 지갑이 익스텐션 wallet의 목표이기 때문에, 로컬에 저장하는 방식이라도 어떤 데이터를 저장하여 관리할지 팀원들과 고민을 많이 했다.</li><li>구현 초기에는 Create Wallet 이후 생성된 사용자의 Wallet password, Mnemonic, Privatekey, Publickey, Address 등의 정보를 모두 Chrome Storage에 저장하였고, 이후 수정을 걸쳐 암호화된 소수의 정보들만 저장을 하였다.</li></ul></li></ul><hr><br/>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> project </tag>
            
            <tag> Bithumb </tag>
            
            <tag> NEO </tag>
            
            <tag> BTA03 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project3 JDEX</title>
      <link href="/2022/10/03/project3/"/>
      <url>/2022/10/03/project3/</url>
      
        <content type="html"><![CDATA[<h1 id="JDEX"><a href="#JDEX" class="headerlink" title="JDEX"></a>JDEX</h1><br/><h2 id="1-팀-소개"><a href="#1-팀-소개" class="headerlink" title="1. 팀 소개"></a>1. 팀 소개</h2><h2 id="BEB-05-Final-Project-Team-04"><a href="#BEB-05-Final-Project-Team-04" class="headerlink" title="BEB 05 Final Project Team 04"></a>BEB 05 Final Project Team 04</h2><ul><li><p><strong>팀 명 : 종덱스</strong></p></li><li><p><strong>프로젝트 명 : JDEX</strong></p></li><li><p><strong>팀장 : 서종대</strong></p></li><li><p><strong>팀원 : 김윤겸, 홍유진</strong></p></li><li><p><strong>Github Repo : <a href="https://github.com/yu-uj/BEB-05-final-JDEX">https://github.com/yu-uj/BEB-05-final-JDEX</a></strong></p></li><li><p><strong>Date : 2022&#x2F;08&#x2F;31 - 2022&#x2F;09&#x2F;30</strong></p></li><li><p><strong>팀 룰</strong></p><p>  → 매일 오전 10시, 오후 5시 필수 회의 진행회의록 작성</p><p>  → 회의록 작성</p><p>  → 그 날의 진행 계획 및 진행 중인 상황 공유</p></li></ul><br/><br/><h2 id="2-프로젝트-개요"><a href="#2-프로젝트-개요" class="headerlink" title="2. 프로젝트 개요"></a>2. 프로젝트 개요</h2><h3 id="💸-JDEX-프로젝트-목표"><a href="#💸-JDEX-프로젝트-목표" class="headerlink" title="💸 JDEX 프로젝트 목표"></a>💸 <strong>JDEX 프로젝트 목표</strong></h3><h3 id="→-Klaytn-기반의-DEX-탈중앙화거래소-구현"><a href="#→-Klaytn-기반의-DEX-탈중앙화거래소-구현" class="headerlink" title="→ Klaytn 기반의 DEX(탈중앙화거래소) 구현."></a>→ <em>Klaytn 기반의 DEX(탈중앙화거래소) 구현.</em></h3><aside>➡️ **DEX; (Decentralized Exchange)**<p><strong>기존의 중앙화거래소(CEX)가 아닌 개인 간 금융(P2P)이 가능한 탈중앙화(분산형) 거래소.</strong> 법정화폐와 암호화폐간의 교환을 허용하지 않고, 암호화폐 토큰을 다른 암호화폐 토큰과 거래하여 블록체인(분산 원장) 위에 구축 및 기록된 <strong>스마트계약의 집합</strong>이다.</p></aside><br/><h3 id="💸-JDEX-란"><a href="#💸-JDEX-란" class="headerlink" title="💸 JDEX 란 ?"></a>💸 <strong>JDEX</strong> 란 ?</h3><blockquote><p><strong>이젠 직접 자산을 관리하고 예치하세요.</strong></p></blockquote><p><strong>JDEX</strong>는 기존의 중앙화된 거래소의 제삼자 개입 없이 <strong>개인 간 금융(P2P) 거래가 가능한 탈중앙화 거래소</strong> 입니다.</p><p>누구나 JDEX 웹 사이트에 방문하여 <strong>지갑</strong>(Kaikas)를 연결하고 보유하고 있는 토큰을 다른 사용자에게 <strong>전송</strong>하거나 다른 토큰으로 <strong>교환</strong> 할 수 있습니다.</p><p>또, 토큰을 지갑에 가지고만 있는 것이 아닌, <strong>단일 혹은 페어 풀에 예치</strong>하고, 유동성 제공에 대한 <strong>보상</strong>(JDEXTOKEN)을 얻을 수 있습니다.</p><br/><h3 id="💸-JDEX-의-대표-기능"><a href="#💸-JDEX-의-대표-기능" class="headerlink" title="💸  JDEX 의 대표 기능"></a>💸  <strong>JDEX</strong> 의 대표 기능</h3><ul><li><p><strong>My Token</strong></p><p>  : 소유하고 있는 토큰 목록을 확인하고, 다른 사람에게 원하는 토큰을 <strong>전송</strong> 할 수 있습니다.</p></li><li><p><strong>Swap</strong></p><p>  : 소유하고 있는 토큰을 다른 토큰들로 <strong>교환</strong>할 수 있습니다.</p></li><li><p><strong>Staking</strong></p><p>  : 소유하고 있는 토큰을 <strong>풀</strong>에 <strong>예치</strong>하여 <strong>’JDEXTOKEN’을 보상</strong>으로 받을 수 있습니다.</p></li></ul><br/><h3 id="⛓️-왜-Klaytn-인가"><a href="#⛓️-왜-Klaytn-인가" class="headerlink" title="⛓️ 왜 Klaytn 인가 ?"></a>⛓️ 왜 Klaytn 인가 ?</h3><ol><li><strong>저비용</strong><ol><li>트랜잭션에서 발생하는 <strong>가스비가 1~20원 수준</strong>으로, <strong>이더리움의 1&#x2F;100</strong>에 해당하는 가스 비용을 필요로 하여 매우 저렴합니다.</li></ol></li><li><strong>높은 확장성(TPS)</strong> <ol><li>Klaytn은 실제 <strong>4000TPS</strong>의 트랜잭션 처리량을 가집니다. 이는 <strong>1초에 4000트랜잭션이 한 블록에 들어가는 확장성</strong>으로, 20TPS(Block Interval 15초)의 이더리움과 7TPS(Block Interval 10분)의 비트코인에 비교했을 때 월등히 높은 TPS 입니다.</li></ol></li><li><strong>짧은 완결성(Finality)</strong><ol><li>완결성은 <strong>블록에 담긴 거래가 바뀔 수 없다는 것을 보증하는 시간</strong>으로, 블록 생성 간격(Block Interval) * 검증 횟수로 계산합니다. 클레이튼은 <strong>1초의 완결성</strong>을 가져 초당 한 건의 <strong>합의와 동시에 처리</strong>합니다. 이더리움의 6분, 비트코인의 60분과 비교하여 매우 짧은 완결성을 가집니다.</li></ol></li><li><strong>새로운 시도</strong><ol><li>Klaytn에 비하여 ETH는 접할 기회가 많았기 때문에 이번 프로젝트를 통해 <strong>Klaytn Chain을 경험</strong>하고, 배우고 싶었습니다.</li></ol></li></ol><br/><h3 id="⛓️-왜-Klaytn-기반의-DEX인가"><a href="#⛓️-왜-Klaytn-기반의-DEX인가" class="headerlink" title="⛓️ 왜 Klaytn 기반의 DEX인가 ?"></a>⛓️ 왜 Klaytn 기반의 DEX인가 ?</h3><ol><li>기존의 보편화 된 덱스들은 이더리움의 메이저 덱스인 <strong>유니스왑</strong> 혹은 <strong>스시스왑</strong>을 클론 코딩하여 배포하였습니다. <strong>JDEX</strong>는 Klaytn에서 자체적으로 제공하는 <strong>Klaytn Dex Contracts</strong>를 분석하고, 배포하는 과정을 거쳐 KIP 컨트랙트 대신 이더리움의 ERC 컨트랙트를 수정하여 사용한 기존 Klaytn 덱스들과 <strong>차별점</strong>을 두었습니다.</li><li><strong>개인 간 금융</strong>(P2P)이 이루어지는 DEX에서 저희가 중요하게 생각한 2가지 <strong>수수료</strong>와 <strong>전송 속도</strong>입니다. 탈중앙화 거래소(DEX)인 만큼 중앙화거래소(은행)과는 다른 장점이 있어야 한다고 생각했고, 수업을 통해 배운 ETH는 비싼 수수료와 느린 전송 속도로 체인으로의 뚜렷한 장점을 찾지 못하였습니다. 그래서 상대적으로 <strong>가스비가 저렴</strong>하고, <strong>속도가 빠른 Klaytn Chain</strong>을 선택하게 되었습니다.</li></ol><br/><br/><h2 id="3-기능별-시연-영상"><a href="#3-기능별-시연-영상" class="headerlink" title="3. 기능별 시연 영상"></a>3. 기능별 시연 영상</h2><ul><li><p><strong>Connect Wallet</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193564278-4a768ce2-8721-4325-a885-58fc6360881b.gif" alt="wallet"></p><ul><li>Kailkas 지갑 연결을 위한 모달 창을 보여줍니다.</li></ul></li><li><p><strong>My Token</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193564312-b6082a62-6f87-410c-9212-a340e3b1fbd8.gif" alt="Transfer"></p><ul><li><strong>My Token List</strong><ul><li>연결된 지갑 보유한 Klay 토큰 및 KIP7 토큰 리스트업 합니다.</li></ul></li><li><strong>Transfer - 토큰 전송</strong><ul><li>보유한 토큰을 다른 사람에게 전송할 수 있습니다.</li></ul></li></ul></li><li><p><strong>Swap</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193564347-a3c9a999-ae98-44e8-8620-414f033e2a05.gif" alt="swap"></p><ul><li>보유한 Klay &#x2F; KIP7 토큰을 원하는 다른 KIP7 토큰으로 교환 할 수 있습니다.</li></ul></li><li><p><strong>Staking - 단일 예치</strong></p><ul><li><p>보유한 토큰을 예치하고, 유동성에 대한 보상(LP Token)을 받습니다.</p></li><li><p><strong>Single Pool List</strong></p><p>  <strong>[ Deposit - 예치 ]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193564394-8be9b6fa-927b-4328-9270-de635503013f.gif" alt="singlepool"></p><p>  <strong>[ Withdraw - 출금 ]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193564416-e7297b66-8dd1-4d4f-9808-4d246afd3589.gif" alt="singlewithdraw"></p><ul><li>단일 풀 목록이 리스트 업 됩니다.</li><li>풀을 선택하여 단일 예치(Deposit)와 출금(Withdraw)가 가능합니다.</li></ul></li></ul></li><li><p><strong>Staking - 페어 예치</strong></p><ul><li><p>보유한 토큰을 예치하고, 유동성에 대한 보상(LP Token)을 받습니다.</p></li><li><p><strong>Pair Pool List</strong></p><p>  <strong>[ Deposit - 예치 ]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193564985-0b65695a-bd73-4253-ab97-f80208fff057.gif" alt="pairpool"></p><p>  <strong>[ Withdraw - 출금 ]</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193565016-30878f12-74a4-4c69-98ea-697129a32f14.gif" alt="pairwithdraw"></p><ul><li>ALL &#x2F; Klay &#x2F; KIP 페어 풀 목록이 리스트 업 됩니다.</li><li>원하는 페어 풀을 선택하여 토큰 페어 예치(Deposit)와 출금(Withdraw)가 가능합니다.</li></ul></li><li><p><strong>Create Pool</strong></p><p>  <img src="https://user-images.githubusercontent.com/99964401/193565047-24599c7c-2e84-4a2a-b995-0fbd10f6f177.gif" alt="create"></p><ul><li>원하는 토큰 페어의 유동성 풀을 생성할 수 있습니다.</li></ul></li></ul></li></ul><br/><br/><h2 id="4-관련-문서"><a href="#4-관련-문서" class="headerlink" title="4. 관련 문서"></a>4. 관련 문서</h2><h3 id="📋-DB-Schema"><a href="#📋-DB-Schema" class="headerlink" title="📋 DB Schema"></a>📋 DB Schema</h3><img width="613" alt="DB" src="https://user-images.githubusercontent.com/99964401/193568157-2b32a512-8f18-4274-b14f-9d59167e2f0a.png"><br/><h3 id="📋-DB-Api"><a href="#📋-DB-Api" class="headerlink" title="📋 DB Api"></a>📋 DB Api</h3><img width="698" alt="API_List" src="https://user-images.githubusercontent.com/99964401/193606675-3742b16f-c9fc-49aa-9127-11a96ad83b4b.png"><br/><h3 id="📋-Wireframe"><a href="#📋-Wireframe" class="headerlink" title="📋 Wireframe"></a>📋 Wireframe</h3><p><img src="https://user-images.githubusercontent.com/99964401/193565105-dad5b57b-f986-43b2-8969-44a5670d7e7e.png" alt="JDEX_Wireframe"></p><br/><h3 id="📋-Flow-Chart"><a href="#📋-Flow-Chart" class="headerlink" title="📋 Flow Chart"></a>📋 Flow Chart</h3><p><img src="https://user-images.githubusercontent.com/99964401/193568279-245cb89f-ad5a-4cde-8a1a-3534dadcb98f.png" alt="JDEX Flowchart Final drawio"></p><br/><h3 id="📋-Token-Economy"><a href="#📋-Token-Economy" class="headerlink" title="📋 Token Economy"></a>📋 Token Economy</h3><img width="1709" alt="JDEX_TokenEconomy" src="https://user-images.githubusercontent.com/99964401/193568712-eba90a3c-1c83-4d93-9294-a3795ec1a5b1.png"><p><strong>[JDEX의 Token Economy]</strong></p><ul><li><strong>개발자, 투자자, 유저</strong>들에게 적절한 양의 <strong>토큰을 분배</strong>하고, **예치(단일, 페어 풀)**에 대한 <strong>보상</strong>으로 <strong>JDX 토큰을 지급</strong> 받아 지속가능한 시스템을 구축하고자 하였습니다.</li><li>보상으로 주어지는 <strong>JDX 토큰</strong>을 <strong>일정 지분 보유</strong>시 <strong>JDEX의 운영 방향성 및 협의</strong>에 대한 <strong>투표 거버넌스에 참여</strong>할 수 있습니다.</li></ul><br/><br/><div align=center><h1>📚 JDEX STACKS</h1></div><div align=center>   <div align=center><h3>COLLABORATION TOOL</h3></div>  <img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">  <img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">  <img src="https://img.shields.io/badge/discord-5865F2?style=for-the-badge&logo=discord&logoColor=white">  <img src="https://img.shields.io/badge/notion-000000?style=for-the-badge&logo=notion&logoColor=white">  <br>    <div align=center><h3>FRONTEND</h3></div>  <img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white">   <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black">   <img src="https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=black">  <img src="https://img.shields.io/badge/bootstrap-7952B3?style=for-the-badge&logo=bootstrap&logoColor=white">   <br>  <img src="https://img.shields.io/badge/typescript-3178C6?style=for-the-badge&logo=typescript&logoColor=white">  <img src="https://img.shields.io/badge/axios-5A29E4?style=for-the-badge&logo=axios&logoColor=white">  <img src="https://img.shields.io/badge/redux-764ABC?style=for-the-badge&logo=redux&logoColor=white">  <img src="https://img.shields.io/badge/Caver-005A2B?style=for-the-badge&logo=Caver&logoColor=white">  <img src="https://img.shields.io/badge/figma-F24E1E?style=for-the-badge&logo=redux&logoColor=white">  <br>    <div align=center><h3>BACKEND</h3></div>  <img src="https://img.shields.io/badge/node.js-339933?style=for-the-badge&logo=Node.js&logoColor=white">  <img src="https://img.shields.io/badge/express-000000?style=for-the-badge&logo=express&logoColor=white">  <img src="https://img.shields.io/badge/mongoDB-47A248?style=for-the-badge&logo=MongoDB&logoColor=white">  <img src="https://img.shields.io/badge/Mongoose-D0021B?style=for-the-badge&logo=Mongoose&logoColor=white">  <img src="https://img.shields.io/badge/.env-ECD53F?style=for-the-badge&logo=.env&logoColor=white">  <br>    <div align=center><h3>BLOCKCHAIN</h3></div>  <img src="https://img.shields.io/badge/solidity-363636?style=for-the-badge&logo=solidity&logoColor=white">  <img src="https://img.shields.io/badge/hardhat-124191?style=for-the-badge&logo=hardhat&logoColor=white">  <img src="https://img.shields.io/badge/truffle-840010?style=for-the-badge&logo=truffle&logoColor=white">  <img src="https://img.shields.io/badge/Kaikas-F5AE29?style=for-the-badge&logo=Kailkas&logoColor=black">  <img src="https://img.shields.io/badge/KlaytnIDE-003366?style=for-the-badge&logo=KlaytnIDE&logoColor=white">  <img src="https://img.shields.io/badge/ganache-A42E2B?style=for-the-badge&logo=ganache&logoColor=white">  <br>  </div><br/><br/><h2 id="회고"><a href="#회고" class="headerlink" title="회고"></a>회고</h2><p>BEB 부트캠프의 가장 장기 프로젝트인 파이널 프로젝트를 끝냈다.<br>이번 프로젝트는 클레이튼 체인을 사용한 탈중앙화거래소(DEX)를 직접 구현해보는 것이었다.<br>프로젝트 시작 전까지 나는 DEX에 대해 잘 몰랐다. DEX와 De-Fi에 대해서는 인지하고 있었으나, 사용해본 경험이 없었다.<br>그래서 블록체인을 사용한 금융, 전자화폐를 거래하는 로직과 동향을 먼저 파악했다.<br>그럼에도 이해가 가지 않는 부분이 존재했는데, 유동성 공급이라던가 페어풀에 예치했을 경우 받는 보상의 존재 등 궁금한 점이 생길 때마다 팀원분들께 물어봤던 것 같다.<br><br/><br>우선 우리 팀원 분들은 매우 성실하고, 열정이 넘치고, 유쾌했다.<br>다들 진행 방향을 정하는데 적극적이고 망설임은 적었다. 서로의 의견을 추합하는 과정도 힘든 적이 없었다.<br>공부하고 성장하기 위한 프로젝트이며, 덱스의 구조를 이해하고 넘어가자는 우리 팀의 취지에 맞게 포지션을 나누지 않고 풀스택으로 진행했다.<br>테스크 공유는 각 맡은 페이지와 기능 별로 진행했으며 매일 하루 두번은 필수로 회의를 진행해서 진행 상황을 공유했다.<br>이 개발 프로세스가 좋았던 것은 우리는 회의를 자주 진행해서 각자 맡은 파트에 이슈가 생길 때 마다 같이 고민해서 해결했고,<br>개인이 진행한 부분의 코드 리뷰를 반드시 한 덕분에 다른 사람이 개발한 부분까지도 이해도가 높았다.<br>때문에 이슈가 발생 했을 때 해결할 방법이 생각난 사람과 테스크를 변경하여 진행하는 것도 가능했다.<br>물론 프로젝트 중간에 컨트랙트 배포 부분은 공동으로 진행했다.<br>우리는 클레이튼의 자체적인 덱스 컨트랙트를 사용하기 위해 방대한 자료를 봐야해서 많은 시간이 소요될 것을 예상했지만,<br>KIP7토큰 발행부터 전송, 스왑, 풀생성, 스테이킹, 보상 지급까지 하나 하나 우리가 배포했기 때문에 더욱 오래 걸렸다.<br>밤새 컨트랙트를 배포하고, 트랜잭션을 확인하고, 구조 파악에서 성공까지 정신은 피폐했지만 결코 포기하지 않았다.<br>어느 것 하나 우리 손을 거치지 않은 것이 없기 때문에 평가 크루분들의 냉혹한 반응에도 더 뿌듯한 마음으로 끝냈던 것 같다.<br>마음같아서는 수많은 실패 트랜잭션까지도 인쇄해서 방마다 붙여놓고 싶은 심정이다ㅋ<br><br/><br>그리고 이번 프로젝트 팀은 팀원들의 격려와 서로 서로의 협동심이 빛났던 팀이었다.<br>팀원들과 소통을 자주 하니, 코드에 대한 이해도 또한 높아졌고 프로젝트에 대한 애정도 커졌다.<br>그래서 마무리를 잘 끝낸 것만으로도 팀원 모두 감격했고, 다른 사람들의 평가가 어떻든 정말 신경도 쓰이지 않았다.<br>JDEX는 내게 아주 소중한 프로젝트 경험이 될 것 같다.<br><br/><br><br/></p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project2 HALP ME!!</title>
      <link href="/2022/08/29/project2/"/>
      <url>/2022/08/29/project2/</url>
      
        <content type="html"><![CDATA[<h1 id="HALP-ME"><a href="#HALP-ME" class="headerlink" title="HALP ME!!"></a>HALP ME!!</h1><h2 id="BEB-05-Second-Project-Team-05"><a href="#BEB-05-Second-Project-Team-05" class="headerlink" title="BEB 05 Second Project Team 05"></a>BEB 05 Second Project Team 05</h2><h2 id="💡Project-Intro"><a href="#💡Project-Intro" class="headerlink" title="💡Project Intro"></a>💡Project Intro</h2><blockquote><p><strong>Web2.0에서 블록체인 인센티브 기반 커뮤니티 사이트를 개발.</strong></p><ul><li>목표 : 중앙화된 Web2.0 인센티브 기반 커뮤니티 구현.</li><li>기획 구분 : FE, BE, SmartContract.</li></ul></blockquote><h2 id="Incentive-Community"><a href="#Incentive-Community" class="headerlink" title="Incentive Community ?"></a>Incentive Community ?</h2><aside>➡️ 인센티브 기반 ?<p><strong>자체적인 토큰을 가지고 참여자를 유도</strong>하는 생태계 빌딩. 사용자가 어떤 행동을 했을 때 <strong>토큰을 인센티브로 지급</strong>하는 것. </p></aside><h2 id="프로젝트-구조"><a href="#프로젝트-구조" class="headerlink" title="프로젝트 구조"></a>프로젝트 구조</h2><blockquote><p>인센티브 기반 커뮤니티 구성 : <strong>FE, BE, SmartContract.</strong></p><ul><li>각 부분 마다 달성 <strong>Bare minimum</strong> 존재.</li></ul></blockquote><p>→ 웹페이지 설계 부분은 기본적인 가이드라인 제공.</p><h3 id="기획"><a href="#기획" class="headerlink" title="기획"></a>기획</h3><blockquote><p>**인센티브 커뮤니티(;IC)**는 <strong>특정한 주제를 좋아하는 사람들이 모여서 게시글을 작성</strong>하는 곳. 특정 주제를 좋아하는 사람들이 모여서 정보와 일상을 나누며 활발한 웹페이지가 되는 것이 목표.</p></blockquote><ul><li>사용자가 커뮤니티에 게시글 작성할 때마다 IC 토큰을 보상으로 받는다.</li><li>해당 IC 토큰은 타인에게 전송 가능하다.</li><li>IC 토큰을 사용하여 NFT 민팅을 할 수 있다.</li><li>해당 NFT는 유저가 원하는 사진으로 만든다.</li><li>마이페이지에서 내가 받은 IC 토큰의 개수와 내가 구입한 NFT를 확인할 수 있다.</li><li>마이페이지에서 내가 쓴 글을 볼 수 있다.</li><li>마이페이지에서 타인에게 내가 가진 토큰을 줄 수 있다.</li></ul><p>→ 토큰 보상 유발 행위 : 게시글 작성. But, 게시글 작성 이외 다른 것을 해도 ㄱㅊ.</p><p>→ 기본적인 기획 이외의 추가할 기획이 있으면 추가해도 되지만, 기본적인 기획은 프로젝트에 반드시 포함.</p><h3 id="프로젝트-요구사항"><a href="#프로젝트-요구사항" class="headerlink" title="프로젝트 요구사항"></a>프로젝트 요구사항</h3><ul><li>커뮤니티에 게시글을 작성(혹은 댓글을 다는 등, 자유롭게 설정)할 수 있고, 이에 따른 보상으로 ERC-20 토큰을 지급하는 기능 (핵심 feature)<ul><li>‘특정 주제’를 좋아하는 사람들의 모임을 활성화하기 위함</li><li>‘특정 주제’는 자유롭게 설정이 가능함</li></ul></li><li>ERC-20 토큰을 ERC-721 토큰과 교환할 수 있는 기능<ul><li>ERC-20의 경우, 서버 ↔ 사용자, 사용자 ↔ 사용자 둘 다 가능해야 함</li></ul></li><li>회원가입 시 자동으로 지갑 주소를 부여받는 기능</li><li>Daemon을 개발하여 트랜잭션을 트래킹할 수 있는 기능</li><li>NFT를 민팅할 수 있는 기능</li><li>내 정보를 볼 수 있어야 함</li></ul><hr><h2 id="🚨-팀-소개"><a href="#🚨-팀-소개" class="headerlink" title="🚨 팀 소개"></a>🚨 팀 소개</h2><h3 id="BEB-05-02-05조"><a href="#BEB-05-02-05조" class="headerlink" title="BEB-05-02-05조"></a>BEB-05-02-05조</h3><h3 id="💡Project-HALP-ME"><a href="#💡Project-HALP-ME" class="headerlink" title="💡Project : HALP ME!!"></a>💡Project : HALP ME!!</h3><ul><li><strong>팀명 : HALP ME!</strong></li><li><strong>팀장 : 홍유진</strong></li><li><strong>팀원 : 박수연, 이송영, 안병현</strong></li><li><strong>Site  Link</strong> :</li><li><strong>Date</strong> : 2022&#x2F;08&#x2F;17 - 2022&#x2F;08&#x2F;30</li></ul><h3 id="💡-HALP-Project-Intro"><a href="#💡-HALP-Project-Intro" class="headerlink" title="💡 HALP Project Intro"></a>💡 HALP Project <strong>Intro</strong></h3><aside>➡️ 질의응답 커뮤니티. 사용자는 질문에 대한 게시글을 작성하고, 다른 사용자들이 해당 게시글에 답변을 댓글로 작성한다. 질문을 한 사용자는 게시글에 달린 답변 댓글 중 가장 적합한 답변을 채택한다. 채택받은 댓글의 사용자는 IC토큰을 보상으로 받는다.</aside><h3 id="역할"><a href="#역할" class="headerlink" title="역할"></a>역할</h3><table><thead><tr><th>이름</th><th>포지션</th></tr></thead><tbody><tr><td>박수연</td><td>FE</td></tr><tr><td>이송영</td><td>FE</td></tr><tr><td>안병현</td><td>BE, SC</td></tr><tr><td>홍유진</td><td>BE, SC</td></tr></tbody></table><p>💻 <strong>FE</strong></p><blockquote><p>웹의 View를 유저 플로우에 따라 구성할 수 있고, 개발하기.</p></blockquote><p>💻 <strong>SC</strong></p><blockquote><p>스마트 컨트랙트 개발을 위해 솔리디티 언어를 다루고, 분석하고, 적용 가능. 기본으로 제공되는 ERC-20, ERC-721 스마트 컨트랙트 코드 외의 덧붙일 기능은 응용하여 코드 작성해야함.</p></blockquote><p>→ 솔리디티로 작성된 ERC-20,  ERC-721 코드를 파악하고, 응용할 수 있다.</p><p>💻 <strong>BE</strong></p><blockquote><p>백엔드에서 지갑 생성, 서명 및 전송 담당. 서버 구축, 지갑 생성 및 관리, 스마트 컨트랙트와 서버를 연동하여 사용. 동작 확인을 위해 실시간 트래킹.</p></blockquote><h2 id="저장소"><a href="#저장소" class="headerlink" title="저장소"></a>저장소</h2><h3 id="팀-레포"><a href="#팀-레포" class="headerlink" title="팀 레포"></a>팀 레포</h3><p><a href="https://github.com/codestates/BEB-05-HALPME">https://github.com/codestates/BEB-05-HALPME</a></p><h3 id="개인-레포"><a href="#개인-레포" class="headerlink" title="개인 레포"></a>개인 레포</h3><p><a href="https://github.com/yu-uj/BEB-05-HALPME">https://github.com/yu-uj/BEB-05-HALPME</a></p><hr><h2 id="기술-스택"><a href="#기술-스택" class="headerlink" title="기술 스택"></a>기술 스택</h2><h3 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h3><table><thead><tr><th>Language</th><th>JavaScript</th><th>*</th></tr></thead><tbody><tr><td>Server Framework</td><td>Node.js</td><td>*</td></tr><tr><td>Contract Language</td><td>Solidity</td><td>SC</td></tr><tr><td>Container</td><td>Ganache</td><td>SC</td></tr><tr><td>Web Library</td><td>React</td><td>FE</td></tr><tr><td>Database(DB)</td><td>MySQL</td><td>BE</td></tr><tr><td>Web Library</td><td>Redux</td><td>FE</td></tr><tr><td>Web Library</td><td>Babel</td><td>BE</td></tr><tr><td>Web Library</td><td>Bootstrap</td><td>FE</td></tr><tr><td>Web Framework</td><td>Express.js</td><td>BE</td></tr><tr><td>JavaScript Library</td><td>Web3.js</td><td>SC</td></tr><tr><td>Framework</td><td>Truffle</td><td>SC</td></tr><tr><td>Framework</td><td>OpenZepplin</td><td>SC</td></tr></tbody></table><h3 id="Position-Tech"><a href="#Position-Tech" class="headerlink" title="Position Tech"></a>Position Tech</h3><table><thead><tr><th>Position</th><th>기술 스택</th></tr></thead><tbody><tr><td>Front-End</td><td>React, Redux, Bootstrap</td></tr><tr><td>Back-End</td><td>MySQL, Babel, Express</td></tr><tr><td>Smart-Contract</td><td>Solidity, Web3.js, Truffle, OpenZepplin</td></tr></tbody></table><h3 id="개발-환경"><a href="#개발-환경" class="headerlink" title="개발 환경"></a>개발 환경</h3><table><thead><tr><th>OS</th><th>MacOS, Ubuntu</th></tr></thead><tbody><tr><td>IDE</td><td>VisualStudioCode</td></tr><tr><td>개발 도구</td><td>Git</td></tr><tr><td>개발 언어</td><td>JavaScript, Solidity</td></tr><tr><td>테스트 네트워크</td><td>Ganache(ETH)</td></tr><tr><td>지갑</td><td>MetaMask</td></tr><tr><td>문서 관리</td><td>Notion</td></tr></tbody></table><hr><h2 id="구현-기능"><a href="#구현-기능" class="headerlink" title="구현 기능"></a>구현 기능</h2><h3 id="🔗-주요-기능"><a href="#🔗-주요-기능" class="headerlink" title="🔗 주요 기능"></a>🔗 주요 기능</h3><p><strong>▶️ 회원관리</strong></p><ul><li><input disabled="" type="checkbox"> 사용자는 아이디와 패스워드를 입력하여 회원가입할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 아이디와 패스워드를 사용하여 로그인할 수 있다.</li></ul><p><strong>▶️ 게시글</strong></p><ul><li><input disabled="" type="checkbox"> 사용자는 게시글을 작성할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 게시글 목록을 확인할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 게시글 상세 내용을 확인할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 게시글에 대한 댓글을 작성할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 자신의 게시글에 달린 댓글 중 하나의 댓글을 채택할 수 있다.</li></ul><p><strong>▶️ 마이페이지</strong></p><ul><li><input disabled="" type="checkbox"> 사용자는 자신의 정보를 확인할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 자신이 소유한 NFT 목록을 확인할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 자신이 소유한 토큰의 개수를 확인할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 자신이 작성한 게시글을 확인할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 자신의 토큰을 다른 사용자에게 전송할 수 있다.</li></ul><p><strong>▶️ 토큰</strong></p><ul><li><input disabled="" type="checkbox"> 사용자는 자신이 작성한 댓글이 채택됨으로, 토큰을 획득할 수 있다.</li></ul><p><strong>▶️ NFT</strong></p><ul><li><input disabled="" type="checkbox"> 사용자는 NFT를 생성할 수 있다.</li></ul><h3 id="🔗-추가-기능"><a href="#🔗-추가-기능" class="headerlink" title="🔗 추가 기능"></a>🔗 추가 기능</h3><p><strong>▶️ 게시글</strong></p><ul><li><input disabled="" type="checkbox"> 사용자는 자신이 작성한 게시글을 수정할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 자신이 작성한 게시글을 삭제할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 자신이 작성한 댓글을 수정할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 자신이 작성한 댓글을 삭제할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 게시글에 좋아요를 표시할 수 있다.</li><li><input disabled="" type="checkbox"> 사용자는 댓글에 좋아요를 표시할 수 있다.</li></ul><h3 id="🔗-Night-Mare"><a href="#🔗-Night-Mare" class="headerlink" title="🔗 Night Mare"></a>🔗 Night Mare</h3><ul><li><input disabled="" type="checkbox"> 사용자는 소유한 nft를 전송할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 nft를 고정된 가격에 구매하거나 경매할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 카테고리의 Explore에서 nft 조회 방식을 선택할 수 있다</li></ul><img width="709" alt="스크린샷 2022-08-30 오후 5 06 46" src="https://user-images.githubusercontent.com/99964401/187392230-8b990b1d-af26-438a-8e00-374e469811e1.png"><br/><h2 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h2><p><strong>Home</strong></p><ul><li>기본 Index 화면.</li><li>왼쪽 상단의 사이트 로고 클릭시 홈(Home)으로 이동한다.</li></ul><p><strong>Navigation</strong></p><ul><li>Home 화면 상단에 위치.</li><li>Login &#x2F; Sign 클릭시 login과 sign 선택 화면으로 이동한다.</li><li>Market 클릭시 market 화면으로 이동한다.</li><li>Create 클릭시 NFTcreate 화면으로 이동한다.</li><li>My Page 클릭시 mypage 화면으로 이동한다.</li></ul><p><strong>Login &#x2F; Sign up</strong></p><ul><li>Home 화면 상단의 오른쪽에 위치.</li><li>Sign 클릭시 회원가입 화면으로 이동한다.</li><li>회원가입에 필요한 Id, Password를 포함한 정보 기입 후, 회원가입 버튼을 클릭하여 가입한다.</li><li>회원가입에 실패하면 error message 송출한다.</li><li>Login 클릭시 로그인 화면으로 이동한다.</li><li>Id, Password 입력 후, 로그인 버튼 클릭으로 로그인한다.</li><li>로그인 실패시 error message 송출한다.</li><li>로그인에 성공하면 화면 오른쪽 상단의 Login 버튼이 Logout 으로 바뀐다.</li><li>Logout 클릭시 사이트에서 로그아웃 된다.</li></ul><p><strong>Market</strong></p><ul><li>게시글 리스트의 게시글 클릭시, 게시글의 상세 페이지로 이동한다.</li><li>게시글 리스트의 상단에 위치한 게시글 작성 버튼을 누르면 게시글 작성 화면으로 이동한다.</li><li>클라이언트는 서버에 NFT 정보를 요청하고 서버는 DB에 저장된 NFT 정보를 응답한다.</li><li>클라이언트는 응답받은 정보를 marketplace 페이지에 보여준다.</li><li>NFT 중 하나를 눌렀을 때 지갑연결이 되어있으면 구매 페이지로, 아니면 지갑 연결 페이지로 이동한다.</li></ul><p><strong>Create (NFT Create)</strong></p><ul><li><strong>지갑 연결 [URClass eth연결]</strong><ul><li>연결이 되지 않은 상황에오른쪽 위 지갑을 누르거나, 오른쪽 위 사용자를 누르거나, Explore에서 NFT를 눌렀을 때 이동한다.</li><li>지갑을 클릭하면 MetaMask 지갑을 표시한다.</li><li>지갑에 로그인하면 사이트에 로그인된다.</li></ul></li><li>사용자는 자신이 보유한 IC토큰을 인증하고, NFT 생성을 위해 Create 버튼을 눌러 create 화면으로 이동한다.</li><li>클라이언트는 사용자에게 NFT CreationFrom을 제공한다.</li><li>사용자는 이미지와 정보를 입력하고 Create NFT 버튼을 클릭하여 NFT 정보를 IPFS에 업로드 요청한다.</li><li>이미지를 IPFS에 저장 후 이미지 IPFS URI를 입력한 정보에 추가하여 metadata.json 파일을 IPFS에 업로드한다.</li><li>업로드 완료 후, 업로드된 이미지는 My Page의 Minted List에서 확인할 수 있다.</li></ul><p><strong>My Page</strong></p><ul><li>로그인한 사용자의 상세 정보 확인.</li><li>사용자가 보유한 IC토큰을 확인.</li><li>사용자가 보유한 NFT 조회.</li><li>구매한 NFT 목록 조회 &#x2F; 민팅한 NFT 목록 조회.</li><li>사용자가 작성한 게시글 확인.</li><li>사용자가 작성한 댓글 확인.</li></ul><p><strong>필수 구현</strong></p><ul><li>로그인 &#x2F; 로그아웃</li><li>회원가입</li><li>게시글 읽기 및 작성</li><li>게시글에 대한 댓글 작성</li><li>게시글의 작성자가 댓글 채택</li><li>채택된 댓글의 작성자는 보상으로 IC토큰을 받음</li><li>IC토큰을 민팅한 NFT 토큰으로 교환</li><li>NFT Create를 하면 데이터베이스에 저장</li><li>Minted List에서 데이터를 받아와서 보유 NFT 표시</li></ul><p><strong>추가 기능 구현</strong></p><ul><li>내 NFT 컬렉션 페이지 조회 기능.</li><li>사용자 NFT 페이지 조회 기능.</li><li>답변 채택이 완료된 게시글은 완료 리스트로 이동하기.</li><li>보유한 IC토큰과 NFT 전송 기능.</li><li>보유한 NFT 판매 기능.</li></ul><br/><h2 id="Flow-Chart"><a href="#Flow-Chart" class="headerlink" title="Flow Chart"></a>Flow Chart</h2><p><img src="https://user-images.githubusercontent.com/99964401/187382272-fc67e10e-c839-4c98-8f2e-91b359f729f9.png" alt="HALP ME Flowchart drawio final"></p><br/><h2 id="ER-Diagram"><a href="#ER-Diagram" class="headerlink" title="ER-Diagram"></a>ER-Diagram</h2><p><img src="https://user-images.githubusercontent.com/99964401/187381769-7e781965-5ec2-43d3-8cf5-662596be9f28.png" alt="Project2"></p><br/><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><img width="629" alt="스크린샷 2022-08-30 오후 5 42 43" src="https://user-images.githubusercontent.com/99964401/187392336-5983b34c-0411-47d7-b2c1-eddd00a77bfd.png"><img width="629" alt="스크린샷 2022-08-30 오후 5 43 14" src="https://user-images.githubusercontent.com/99964401/187392357-4c2f6067-d86f-46bd-a92c-387f68090dd1.png"><br/><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h3 id="1-env-추가"><a href="#1-env-추가" class="headerlink" title="1. .env 추가"></a>1. <code>.env</code> 추가</h3><p><code>.env</code> 파일을 생성하여 다음과 같이 환경 변수를 추가한다.</p><ul><li>client</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REACT_APP_SECRET_KEY=</span><br><span class="line">REACT_APP_SERVER_URL=http://127.0.0.1:8080</span><br></pre></td></tr></table></figure><ul><li>server</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PORT=8080</span><br><span class="line">SERVER_BANNER=</span><br><span class="line">DB_USER_NAME=root</span><br><span class="line">DB_USER_PASSWORD=</span><br><span class="line">DB_DATABASE_NAME=HALP_ME</span><br><span class="line">DB_HOST=127.0.0.1</span><br><span class="line">DB_DIALECT=mysql</span><br></pre></td></tr></table></figure><ul><li>contract</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SERVER_ADDRESS=가나슈 첫번째 계정</span><br><span class="line">SERVER_SECRET_KEY=가나슈 첫번째 계정 비밀 키</span><br><span class="line">CONTRACT_ADDRESS=내가 배포한 컨트랙트 주소</span><br><span class="line">RPC_URL=http://127.0.0.1:7545/</span><br></pre></td></tr></table></figure><h3 id="2-실행"><a href="#2-실행" class="headerlink" title="2. 실행"></a>2. 실행</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client</span></span><br><span class="line"><span class="built_in">cd</span> client</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line"><span class="comment"># server</span></span><br><span class="line"><span class="built_in">cd</span> server</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h3 id="3-contract-deploy"><a href="#3-contract-deploy" class="headerlink" title="3. contract deploy"></a>3. contract deploy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install truffle &amp; ganache</span></span><br><span class="line">npm install -g truffle</span><br><span class="line">npm install -g ganache-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 프롬프트 실행</span></span><br><span class="line">truffle develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 컴파일</span></span><br><span class="line">compile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 배포</span></span><br><span class="line">migrate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 테스트</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><br/><h1 id="실행-화면"><a href="#실행-화면" class="headerlink" title="실행 화면"></a>실행 화면</h1><h3 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h3><img width="958" alt="home" src="https://user-images.githubusercontent.com/99964401/187381843-cbeb10d7-e266-49ba-b41e-a229d3870713.png"><h3 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h3><img width="943" alt="post" src="https://user-images.githubusercontent.com/99964401/187381872-1d28726b-a21b-4919-891e-87d6e84c393a.png"><h3 id="Post-Create"><a href="#Post-Create" class="headerlink" title="Post Create"></a>Post Create</h3><img width="944" alt="postCreate" src="https://user-images.githubusercontent.com/99964401/187382010-464c0ba3-0342-4609-a002-55e11d7bf863.png"><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><img width="944" alt="comments" src="https://user-images.githubusercontent.com/99964401/187382091-48ff3a1c-0d86-4ff7-aca4-8f29f079ef8c.png"><h3 id="Comments-Selected"><a href="#Comments-Selected" class="headerlink" title="Comments Selected"></a>Comments Selected</h3><img width="943" alt="commentSelected" src="https://user-images.githubusercontent.com/99964401/187382120-e51646eb-b463-406b-9b7c-64ac503bd811.png"><h3 id="Market"><a href="#Market" class="headerlink" title="Market"></a>Market</h3><img width="953" alt="market" src="https://user-images.githubusercontent.com/99964401/187382144-1a46382a-678a-4cff-a9b6-b8661761ddfe.png"><h3 id="My-Page"><a href="#My-Page" class="headerlink" title="My Page"></a>My Page</h3><img width="945" alt="mypage" src="https://user-images.githubusercontent.com/99964401/187382170-d3eba9c8-ae7d-474f-986c-858096510d1c.png"><br/><br/><hr><br/><h2 id="회고"><a href="#회고" class="headerlink" title="회고"></a>회고</h2><p>첫 프로젝트는 그나마 손에 익어있던 프론트엔드를 경험해봐서 두번째 프로젝트는 백엔드에 도전했다.<br>백엔드 포지션 팀원들이 다 경험자 혹은 무경험자이거나, 프론트엔드 포지션에 자리가 빈다면 그쪽으로 갈 생각이었으나.<br>프론트엔드에는 현업을 경험해본 분이 계셨고, 백엔드 지원한 분은 전공자셔서 많이 배워가보고자 도전했다.<br>민폐여도 파이널 이전에는 반드시 백엔드 프로세스를 경험해보고 싶었다.<br><br/><br>첫 팀 회의를 하는데 역시나 내가 이해하고 있는 부분은 몇 없었다^^…<br>식은땀이 삐질삐질 나면서, 아 이거 그냥 프론트로 넘어가야 그나마 도움이 되지 않을까?ㅎ 싶었으나 말을 꺼낼 수 없었다.<br>마음은 급한데 맡은 테스크를 진행할 때 마다 나의 모자람과 무지함이 보였다. 그래서 더욱 가라앉았고 조급했다.<br><br/><br>그래서 스마트 컨트랙트를 꼼꼼히 공부하고 배포하여 프로젝트 진행에 차질을 줄이려고 열심히 했다.<br>생소했던 truffle을 사용하여 ganache 네트워크에 배포하는 과정을 이제는 눈감고도 할 수 있을거 같다.<br>또한 내 장점을 살려 그때마다 문서 정리를 해두고, 팀 회의에 참석하여 진행 상황 전달을 했다.<br><br/><br>프로젝트 진행동안 내 속에서는<br>‘내가 공부를 잘못한걸까?’<br>‘이 부분은 공부를 안했던걸까?’<br>‘다른 분들은 저렇게 능숙하게 작업을 하는데, 나만 못하는 건 내가 많이 부족했나?’<br>이런 끊임없는 의심뿐이었다.<br>도서관에서 책을 빌려서 보고, 유튜브와 내 정리 노션, 유어클래스, 구글을 다 뒤져가면서 공부해도 생소함이 가시지 않았다.<br>내 자신에 대한 의심이 계속해서 일어나니 기분이 점점 가라앉고 회피하고만 싶었다.<br>팀원분들이 잘 이끌어주지 않았다면 이번 프로젝트를 완성시키지 못했을거다.<br></br><br>마지막날, 팀원분과의 회의에서 서로 궁금한 점을 해소하다가 내가 아는 부분을 공유했다.<br>그리고 고심하다가 팀원분께 도움을 요청했다.<br>아직도 이해가 안가는 백엔드 로직과 순서에 대해 부끄럽지만 설명을 부탁했다.<br>나는 누군가에게 도움을 요청하는 것이 굉장히 힘들어서 레퍼런스를 찾고, 공부한 부분을 다시 복기했었는데.<br>팀원분의 설명은 그 모든 것을 넘어 내게 가장 도움이 되었다.<br>프로젝트에 대해서 누구보다 잘 이해하고, 직접 구현까지한 본인의 코드 리뷰와 로직 설명은 엄청난 효율이었다.<br>내가 차마 물어보지 못했던 것은 팀에 도움이 되지 못하는 것을 들키고 싶지 않았던거였다.<br>그리고 팀원분들이 나를 민폐로 여겨 귀찮아할거라는 섣부른 선입견이 존재했다.<br>이번 프로젝트로 소중한 교훈을 얻었다.<br>도움이 필요할 때는 자존심 때문에 혼자 해결하려 하지말고, 도움을 요청하는 것이 팀을 위한 효율이다.</p><br/><br/>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project1 UnderTheSea</title>
      <link href="/2022/08/16/project1/"/>
      <url>/2022/08/16/project1/</url>
      
        <content type="html"><![CDATA[<h1 id="UnderTheSea"><a href="#UnderTheSea" class="headerlink" title="UnderTheSea"></a>UnderTheSea</h1><h2 id="BEB-05-first-Project-Team-02"><a href="#BEB-05-first-Project-Team-02" class="headerlink" title="BEB 05 first Project Team 02"></a>BEB 05 first Project Team 02</h2><h2 id="팀-소개"><a href="#팀-소개" class="headerlink" title="팀 소개"></a>팀 소개</h2><h3 id="BEB-05-01-02조"><a href="#BEB-05-01-02조" class="headerlink" title="BEB-05-01-02조"></a>BEB-05-01-02조</h3><ul><li><strong>팀명 : UnderTheSea 언더더씨</strong></li><li><strong>팀장 : 김윤겸</strong></li><li><strong>팀원 : 박찬우, 서경근, 홍유진</strong></li><li>Site  Link :</li><li>Date : 2022&#x2F;08&#x2F;08 - 2022&#x2F;08&#x2F;16</li></ul><blockquote><p>➡️ <strong>프로젝트 목표</strong></p><h3 id="최대의-NFT-Marketplace-‘OpenSea’를-클론-코딩한-플랫폼-구현"><a href="#최대의-NFT-Marketplace-‘OpenSea’를-클론-코딩한-플랫폼-구현" class="headerlink" title="최대의 NFT Marketplace ‘OpenSea’를 클론 코딩한 플랫폼 구현."></a><strong>최대의 NFT Marketplace ‘OpenSea’를 클론 코딩한 플랫폼 구현.</strong></h3></blockquote><h3 id="역할-분담"><a href="#역할-분담" class="headerlink" title="역할 분담"></a>역할 분담</h3><table><thead><tr><th>이름</th><th>포지션</th></tr></thead><tbody><tr><td>김윤겸</td><td>BE, IPFS</td></tr><tr><td>서경근</td><td>BE</td></tr><tr><td>박찬우</td><td>FE</td></tr><tr><td>홍유진</td><td>FE</td></tr></tbody></table><h2 id="저장소"><a href="#저장소" class="headerlink" title="저장소"></a>저장소</h2><h3 id="팀-레포"><a href="#팀-레포" class="headerlink" title="팀 레포"></a>팀 레포</h3><p><a href="https://github.com/codestates/BEB-05-underthesea">https://github.com/codestates/BEB-05-underthesea</a></p><hr><h2 id="구현-기능"><a href="#구현-기능" class="headerlink" title="구현 기능"></a>구현 기능</h2><h3 id="기본-기능"><a href="#기본-기능" class="headerlink" title="기본 기능"></a>기본 기능</h3><ul><li><input disabled="" type="checkbox"> 사용자는 메타마스크 지갑을 연동하여 로그인 할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 자신이 소유한 nft 목록을 확인할 수 있다</li></ul><h3 id="주요-기능"><a href="#주요-기능" class="headerlink" title="주요 기능"></a>주요 기능</h3><ul><li><input disabled="" type="checkbox"> 사용자는 판매중인 nft 목록을 나열할 수 있다 → 조회 방식 선택(최근 날짜, 인기순, 가격 높은순)</li><li><input disabled="" type="checkbox"> 사용자는 nft의 상세 정보를 확인할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 nft를 생성 및 배포할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 자신의 거래 내역을 확인할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 민팅된 nft를 구매할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 구입한 nft를 판매할 수 있다</li></ul><h3 id="추가-기능"><a href="#추가-기능" class="headerlink" title="추가 기능"></a>추가 기능</h3><ul><li><input disabled="" type="checkbox"> 사용자는 소유한 nft를 전송할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 nft를 고정된 가격에 구매하거나 경매할 수 있다</li><li><input disabled="" type="checkbox"> 사용자는 카테고리의 Explore에서 nft 조회 방식을 선택할 수 있다</li></ul><hr><h2 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h2><p><strong>Home</strong></p><ul><li>기본 홈 화면</li><li>왼쪽 위 마크를 누르면 홈으로 이동한다.</li></ul><p><strong>Explore 및 검색</strong></p><ul><li>검색을 하거나 Explore를 누르면 marketplace로 이동한다.</li><li>클라이언트는 서버에 NFT 정보를 요청하고 서버는 DB에 저장된 NFT 정보를 응답한다.</li><li>클라이언트는 응답받은 정보를 marketplace 페이지에 보여준다.</li><li>NFT 중 하나를 눌렀을 때 지갑연결이 되어있으면 구매 페이지로, 아니면 지갑 연결 페이지로 이동한다.</li></ul><p><strong>지갑 연결</strong></p><ul><li>연결이 되지 않은 상황에오른쪽 위 지갑을 누르거나, 오른쪽 위 사용자를 누르거나, Explore에서 NFT를 눌렀을 때 이동한다.</li><li>지갑을 클릭하면 MetaMask 지갑을 표시한다.</li><li>지갑에 로그인하면 사이트에 로그인된다.</li></ul><p><strong>NFT 만들기</strong></p><ul><li>사용자가 Create 버튼을 눌렀을 때 이동한다.</li><li>클라이언트는 사용자에게 NFT CreationFrom을 제공한다.</li><li>사용자는 이미지와 정보를 입력하고 Create를 클릭한다.</li><li>이미지를 IPFS에 저장 후 이미지 IPFS URI를 입력한 정보에 추가하여 metadata.json 파일을 IPFS에 업로드한다. (-&gt;explore에서 보이게)</li></ul><p><strong>필수 구현</strong></p><ul><li>지갑 연결 로그인</li><li>marketplace에서 데이터 받아와 표시</li><li>NFT Create를 하면 데이터베이스에 저장</li></ul><p><strong>추가 기능 구현</strong></p><ul><li>내가 만든 NFT 컬렉션 페이지 조회</li><li>작가별 NFT 페이지 조회</li><li>market place 정렬 기능 (가격순, 최신순 등)</li></ul><hr><h2 id="To-Do"><a href="#To-Do" class="headerlink" title="To Do"></a>To Do</h2><h3 id="💻-Back-End"><a href="#💻-Back-End" class="headerlink" title="💻 Back End"></a>💻 Back End</h3><p><strong>[ 지갑 연결, 컨트랙트 발행, 기능 구현 ]</strong></p><ul><li><input disabled="" type="checkbox"> Project Setup</li><li><input disabled="" type="checkbox"> [Login &#x2F; Wallet] Connecting MetaMask</li><li><input disabled="" type="checkbox"> NFT contract 구현</li><li><input disabled="" type="checkbox"> Marketplace contract setup</li><li><input disabled="" type="checkbox"> Make Items 구현</li><li><input disabled="" type="checkbox"> Purchase Items 구현</li></ul><h3 id="💻-Front-End"><a href="#💻-Front-End" class="headerlink" title="💻 Front End"></a>💻 Front End</h3><p><strong>[ 개발 환경 구축]</strong></p><ul><li><input disabled="" type="checkbox"> Setup (starter kit)</li><li><input disabled="" type="checkbox"> MetaMask 네트워크에 Hardhat Node 추가</li><li><input disabled="" type="checkbox"> MetaMask 계정을 브라우저와 연결</li><li><input disabled="" type="checkbox"> Components 구성, 라이브러리 추가, Handler 추가, MetaMask 계정 연결을 위한 Hook 추가</li><li><input disabled="" type="checkbox"> 블록체인 연결, 컨트랙트 가져오기</li><li><input disabled="" type="checkbox"> Navbar Components 추가, Nav 구성 및 경로 설정</li><li><input disabled="" type="checkbox"> 지갑 연결 버튼 생성</li></ul><p><strong>[ Home Component ]</strong></p><ul><li><input disabled="" type="checkbox"> 마켓플레이스 nft 컨트랙트 가져오기</li><li><input disabled="" type="checkbox"> ipfs에서 nft 메타데이터 가져오기, API 연결</li><li><input disabled="" type="checkbox"> 판매 아이템 항목 생성</li><li><input disabled="" type="checkbox"> 구매 아이템 항목 생성</li><li><input disabled="" type="checkbox"> 판매되지 않은 아이템 사용자 구매</li><li><input disabled="" type="checkbox"> 항목 조회 완료 전 Loading Page</li><li><input disabled="" type="checkbox"> nft 상세정보(이미지와 이름, 가격, 설명) 맵핑 카드</li><li><input disabled="" type="checkbox"> 가격 단위 wei → eth로 변환</li><li><input disabled="" type="checkbox"> 보유 자산 항목 나열</li></ul><p><strong>[ Create Component ]</strong></p><ul><li><input disabled="" type="checkbox"> 새로 생성된 nft 메타데이터를 ipfs에 업로드</li><li><input disabled="" type="checkbox"> 블록체인에 저장할 nft 메타데이터 입력 양식 생성</li><li><input disabled="" type="checkbox"> 변경 사항을 ipfs에 업로드</li><li><input disabled="" type="checkbox"> 사용자가 생성할 nft 입력 양식 제출시 메타데이터를 ipfs에 업로드</li><li><input disabled="" type="checkbox"> ipfs로부터 민팅된 항목으로 리스트 생성</li><li><input disabled="" type="checkbox"> Home 화면 수정 및 UI 구축</li></ul><p><strong>[ MyListedItems Component ]</strong></p><ul><li><input disabled="" type="checkbox"> 사용자의 nft 리스트 나열</li><li><input disabled="" type="checkbox"> 판매된 nft는 SoldItems로 이동</li><li><input disabled="" type="checkbox"> Home 화면 수정 및 UI 구축</li></ul><p><strong>[ MyPurchases Component ]</strong></p><ul><li><input disabled="" type="checkbox"> 구매한 nft를 MyPurchases로 이동</li><li><input disabled="" type="checkbox"> 사용자가 구매한 아이템 항목 생성</li><li><input disabled="" type="checkbox"> 마켓플레이스의 항목 계정으로 필터링</li><li><input disabled="" type="checkbox"> 구매한 아이템의 메타데이타를 구매 항목 리스트에 업로드</li><li><input disabled="" type="checkbox"> Home 화면 수정 및 UI 구축</li></ul><hr><h3 id="Flow-Chart"><a href="#Flow-Chart" class="headerlink" title="Flow Chart"></a>Flow Chart</h3><p><img src="https://user-images.githubusercontent.com/99964401/184828609-5bbb5b79-2f2d-4819-96b6-e8f41d8e45ea.png" alt="UnderTheSea Flowchart drawio"></p><hr><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><ol><li>git clone </li><li>npm install</li><li>npm start</li></ol><hr><h2 id="프로젝트-회고"><a href="#프로젝트-회고" class="headerlink" title="프로젝트 회고"></a>프로젝트 회고</h2><h3 id="느낀점"><a href="#느낀점" class="headerlink" title="느낀점"></a>느낀점</h3><p>첫 프로젝트는 툴 사용법과 프로젝트 프로세스를 갖추는 과정이 제일 오래 걸렸다.<br>초반에는 어떤식으로 시작해야하는지 우왕좌왕했다.<br>갑자기 벌거벗겨진채로 무인도에 내던져진 문명의 사람같았다.<br>프로젝트 이전에 가장 고민됐던 것이 팀에 도움이 되는 팀원이 될 수 있을까였다.<br>그래서 기를 쓰고 툴을 사용하는 것에 열심히 매달렸던것 같다.<br>첫 날 가장 오랜 시간을 쓰고 당황했던 점을 보완한다면 나의 역할을 완벽하지는 않아도 팀원의 역할은 할 수 있을 것 같았다.<br>찬찬히 일을 분담을 하고 팀원들과 소통을 하면서 안정적이구만…! 싶을 때 위기는 찾아왔다.<br>ipfs에 업로드 하는 infura 이슈로 사용하기로 했ㅓ infura를 nft Storage로 바꿔야 했다.<br>이 과정이 제일 어렵고 고난이었다.<br>여러모로 아쉬운 점이 많았지만, 배운 것도 많았다.<br>팀원들과 같이 어려움을 이겨나가는 것 또한 능력이라는 것?ㅎㅎ<br>아무튼 다들 고생하셨고, 나름 즐거웠던 것 같다.</p><hr><br/>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker / Container</title>
      <link href="/2022/06/10/docker-container/"/>
      <url>/2022/06/10/docker-container/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-설치-x2F-Container-기술"><a href="#Docker-설치-x2F-Container-기술" class="headerlink" title="Docker 설치 &#x2F; Container 기술"></a>Docker 설치 &#x2F; Container 기술</h1><h2 id="Docker-설치"><a href="#Docker-설치" class="headerlink" title="Docker 설치"></a>Docker 설치</h2><ul><li><a href="https://docs.docker.com/desktop/mac/install/">MacOs</a></li><li>Ubuntu - <a href="https://docs.docker.com/engine/install/ubuntu/">Docker Engine</a> &#x2F; <a href="https://docs.docker.com/compose/install/">Docker Compose</a> 설치</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MAC</span></span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">sudo docker --version</span><br></pre></td></tr></table></figure><p><img src="/image/BE/docker-container1.png"></p><hr><h2 id="Docker의-등장-컨테이너-기술-연관성"><a href="#Docker의-등장-컨테이너-기술-연관성" class="headerlink" title="Docker의 등장 - 컨테이너 기술 연관성"></a>Docker의 등장 - 컨테이너 기술 연관성</h2><p><img src="/image/BE/docker-container2.png"></p><p>컨테이너 : 물자를 싣고 내릴 때, 선박이 입항해 있는 시간을 단축, 필요 인력 감소.</p><p>→ 컨테이너 기술을 “소프트웨어 수송, 배포”에 사용 &#x3D; 리눅스 컨테이너(lxc)</p><p>→ 애플리케이션을 쉽게 컨테이너화할 수 있는 생태계 또는 커뮤니티가 없음 </p><p>→ 도커(Docker)는 Docker Hub라는 소프트웨어 저장소와 함께 성장</p><p>→ 쉽게 <strong>애플리케이션을 포장</strong>, <strong>컨테이너 방식으로 실행</strong></p><h3 id="⇒-실행-환경에-구애받지-않고-애플리케이션-실행-가능"><a href="#⇒-실행-환경에-구애받지-않고-애플리케이션-실행-가능" class="headerlink" title="⇒ 실행 환경에 구애받지 않고 애플리케이션 실행 가능"></a>⇒ 실행 환경에 구애받지 않고 애플리케이션 실행 가능</h3><hr><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker?"></a>Docker?</h1><h2 id="컨테이너-방식-장점"><a href="#컨테이너-방식-장점" class="headerlink" title="컨테이너 방식 장점"></a>컨테이너 방식 장점</h2><blockquote><p>의존성 충돌 문제 해결</p></blockquote><blockquote><p>개발과 배포 환경을 일치</p></blockquote><blockquote><p>수평 확장을 쉽게 해줌</p></blockquote><blockquote><p>각 서버에 새로운 내용을 배포하기 쉽게 만듦</p></blockquote><hr><h2 id="1-의존성-충돌-문제-해결"><a href="#1-의존성-충돌-문제-해결" class="headerlink" title="1. 의존성 충돌 문제 해결"></a>1. 의존성 충돌 문제 해결</h2><h3 id="의존-관계"><a href="#의존-관계" class="headerlink" title="#의존 관계"></a>#의존 관계</h3><p>애플리케이션을 실행하기 위해 반드시 필요한 환경이 구축되어 있어야 하는 경우, 윈도우용 프로그램을 실행하기 위해 윈도우 운영체제를 요구하는 것과 같이.</p><p>이처럼 <strong>프로그램 A의 실행에 다른 프로그램 B가 반드시 필요한 경우</strong>를 </p><p><strong>“프로그램 A 는 프로그램 B에 의존 관계를 가지고 있다”</strong> 고 한다.</p><br/><h3 id="의존성-충돌"><a href="#의존성-충돌" class="headerlink" title="#의존성 충돌"></a>#의존성 충돌</h3><p>워드프레스(wordpress) 프로그램이 php 프로그램에 대해 <strong>의존 관계</strong>를 가질 때,</p><p>동일 컴퓨터의 drupal 프로그램도 php 프로그램과 <strong>의존 관계</strong>를 가지고,</p><p><strong>서로 다른 버전을 요구하는 경우</strong>에는 한 컴퓨터에 여러 버전의 동일 애플리케이션이 설치되지 않음.</p><p>→ wordpress 가 요구하는 버전의 php 7</p><p>→ drupal 8.1 가 요구하는 버전의 php 6</p><p><strong>php의 의존 관계를 가진 두 애플리케이션 중 하나는 제대로 실행될 수 없는 경우</strong>를</p><p><strong>“의존성이 충돌한다”</strong> 고 한다.</p><br/><h3 id="컨테이너-기술"><a href="#컨테이너-기술" class="headerlink" title="#컨테이너 기술"></a>#컨테이너 기술</h3><p>컨테이너 기술은 의존성 충돌 문제를 해결한다. 컨테이너 기술은 애플리케이션을 컨테이너 내에 구성한다.</p><p><img src="/image/BE/docker-container3.png"></p><p><strong>⇒ 컨테이너에서 실행 중인 애플리케이션은 어떤 의존성을 공유하지 않고, 각자의 고유한 의존성을 포함하고 있다.</strong></p><p>⇒ 각 컨테이너가 실행 환경이 격리되어 있기 때문에 가능.</p><br/><h3 id="컨테이너-기술-격리-x2F-소유"><a href="#컨테이너-기술-격리-x2F-소유" class="headerlink" title="#컨테이너 기술 격리 &#x2F; 소유"></a>#컨테이너 기술 격리 &#x2F; 소유</h3><p>한 컴퓨터 안에 여러대의 컨테이너가 존재, 이를 통해 애플리케이션 실행 환경 격리.</p><p>컨테이너가 격리하는 자원, 독립적으로 소유하는 자원들은</p><ol><li>프로세스의 구획화<ol><li>특정 컨테이너에서 작동하는 프로세스는 해당 컨테이너 안에서만 액세스 가능하다.</li><li>컨테이너 안에서 실행되는 프로세스는 타 컨테이너의 프로세스에 영향을 줄 수 없다.</li></ol></li><li>네트워크의 구획화<ol><li>기본적으로 컨테이너 하나 당 하나의 IP 주소 할당한다.</li></ol></li><li>파일 시스템의 구획화<ol><li>컨테이너 안에서 사용되는 파일 시스템은 구획화되어 있어 해당 컨테이너에서의 명령, 파일 등의 액세스를 제한할 수 있다.</li></ol></li></ol><hr><h2 id="2-개발과-배포-환경을-일치-시킴"><a href="#2-개발과-배포-환경을-일치-시킴" class="headerlink" title="2. 개발과 배포 환경을 일치 시킴"></a>2. 개발과 배포 환경을 일치 시킴</h2><p>하나의 프로젝트를 위해 여러 개발자가 비슷한 개발 환경을 구축하려고 할 때, 발생할 수 있는 여러가지 문제와 복잡성을 줄여준다.</p><p>도커는 <strong>어떠한 운영체제든 상관없이 같은 명령어로 프로그램을 설치하고 실행</strong>시킬 수 있다.</p><p>[ex. PostgresSQL 설치]</p><p><code>docker run —name postgres -e POSTGRES_PASSWORD=mysecret -d postgres</code></p><p><strong>⇒ 애플리케이션 구성 자체가 컨테이너화되면 (Docker Compose 툴 사용) YAML 파일 + 명령어로 모든 애플리케이션 실행 환경 구성 가능</strong></p><br/><p><code>docker-compose up</code></p><ul><li>OS 상관없이 같은 애플리케이션 실행 환경을 구축</li><li>개발을 컨테이너 위에서 진행할 때, 동일한 환경으로 개발 진행 가능</li></ul><br/><h3 id="배포-시-발생-이슈"><a href="#배포-시-발생-이슈" class="headerlink" title="배포 시 발생 이슈"></a>배포 시 발생 이슈</h3><p><img src="/image/BE/docker-container4.png"></p><p>Amazon Web Service의 EC2 상에 도커를 설치, 혹은 도커 컨테이너를 EC2 서버에서 실행할 수 있게 하는 ECS 서비스를 이용하여 애플리케이션을 쉽게 배포.</p><p>⇒ <strong>AWS ECS는 애플리케이션을 도커 컨테어너째로 배포할 수 있게 해줌.</strong></p><hr><h2 id="3-수평-확장-x2F-4-각-서버에-새로운-내용을-배포-용이"><a href="#3-수평-확장-x2F-4-각-서버에-새로운-내용을-배포-용이" class="headerlink" title="3. 수평 확장 &#x2F; 4. 각 서버에 새로운 내용을 배포 용이"></a>3. 수평 확장 &#x2F; 4. 각 서버에 새로운 내용을 배포 용이</h2><p>글로벌 웹 서비스는 이용자가 많아 트래픽 양도 많다. 서비스 제공자들은 이러한 <strong>트래픽 분산을</strong> 위해 <strong>프록시 서버</strong>를 운영하며, 프록시 서버는 <strong>여러 동일한 검색 서버 중  한 군데를 이용</strong>할 수 있도록 돕는다.</p><p>→ <strong>이러한 서버</strong> &#x3D; <strong>리버스 프록시</strong>의 한 종류인 <strong>“로드 밸런서”</strong> 라고 함.</p><p><img src="/image/BE/docker-container5.png"></p><p><strong>[리버스 프록시 구조]</strong></p><p>컨테이너 기술의 <strong>실행 환경의 일치</strong> 장점은 많은 <strong>트래픽으로 인한 서버 증설에 이용</strong> 된다. 동일한 애플리케이션 구성을 바탕으로 새로운 서버에 <strong>해당 애플리케이션을 컨테이너로 실행, 로드 밸런서에 이 서버를 추가</strong> 시켜준다.</p><p>이를 응용하여 새 버전의 애플리케이션을 여러 서버 중 몇 대에 테스트 운영하는 방법도 가능하다. 새 버전에서 발생할 문제들을 미리 확인 가능하여 사전에 해결.</p><br/><p><img src="/image/BE/docker-container6.png"></p><p><strong>→ 오케스트레이션 도구 : 오케스트레이터를 활용하여 테스트하는 도구 &#x3D; 컨테이너 기술 사용</strong></p><hr><br/>]]></content>
      
      
      <categories>
          
          <category> BE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> BE </tag>
            
            <tag> Docker </tag>
            
            <tag> Container </tag>
            
            <tag> Image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 모듈 사용 / Fetch 네트워크 요청</title>
      <link href="/2022/05/18/nodejs-fetch/"/>
      <url>/2022/05/18/nodejs-fetch/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js-모듈-사용-x2F-Fetch-네트워크-요청"><a href="#Node-js-모듈-사용-x2F-Fetch-네트워크-요청" class="headerlink" title="Node.js 모듈 사용 &#x2F; Fetch 네트워크 요청"></a>Node.js 모듈 사용 &#x2F; Fetch 네트워크 요청</h1><h3 id="JS-x2F-Node-비동기-2"><a href="#JS-x2F-Node-비동기-2" class="headerlink" title="[JS&#x2F;Node] 비동기 2"></a>[JS&#x2F;Node] 비동기 2</h3><hr><h2 id="Node-js-모듈-사용법"><a href="#Node-js-모듈-사용법" class="headerlink" title="Node.js 모듈 사용법"></a>Node.js 모듈 사용법</h2><p>브라우저에서 사용할 수 있는 비동기 흐름은 타이머 혹은 DOM 이벤트와 관련된 상황으로 다소 한정적.</p><p>BUT!</p><p>Node.js의 경우 많은 API가 비동기로 작성됨.</p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js ?"></a>Node.js ?</h2><p>로컬 환경에서 자바스크립트를 실행할 수 있는 자바스크립트 런타임이다. 브라우저에서 불가능한 기능이 가능.</p><blockquote><p><strong>모듈 ?</strong> 어떤 기능을 조립할 수 있는 형태로 만든 부분. fs(File System) 모듈은 PC의 파일을 읽거나 저장하는 일을 지원함.</p></blockquote><p>서버사이트 스크립트 언어가 아닌 프로그램(환경)이다.</p><p>웹서버와 같이 확장성 있는 네트워크 프로그램 제작을 위해 만들어졌다. ⇒ 한가지 언어로 전체 웹 페이지를 만들 수 있게 됨. </p><h3 id="Node-js의-특징"><a href="#Node-js의-특징" class="headerlink" title="Node.js의 특징"></a>Node.js의 특징</h3><ul><li>자바스크립트 언어 사용</li><li>자바스크립트 엔진 사용으로 속도가 빠르다</li><li>이벤트 기반 비동기 방식(Non-Blocking)<ul><li>Node.js 에서 모든 API가 비동기 방식이므로, 호출 후 응답을 기다리지 않고 다른 API를 호출. 이전에 호출한 API의 응답이 오면 이벤트 루프가 확인하여 처리함.</li><li>이벤트 루프(event loop)는 여러 이벤트가 동시 발생했을 때 어떤 순서로 콜백함수를 호출할지 판단.</li><li>비동기란 이전 작업이 완료될 때까지 대기하지 않고 동시에 작업을 수행하는 것.</li></ul></li><li>단일 스레드<ul><li>스레드 : 프로세스 내에서 실행되는 흐름의 단위. 프로세스는 스레드를 여러 개 생성하여 여러 작업을 동시에 처리. 스레드들은 부모 프로세스의 자원을 공유. 같은 주소의 메모리에 접근 가능하여 데이터 공유할 수 있다.</li><li>프로세스 : 운영체제에서 할당하는 작업의 단위. 노드나 웹 브라우저 등의 프로그램은 개별적인 프로세스. 프로세스 간 메모리 자원 공유 x.</li><li>복잡한 비동기 I&#x2F;O 응용 프로그램을 싱글 스레드 자바스크립트로 작성하여 결과물 실행 속도와 개발 편의성이 좋음. 그러나 CPU의 높은 연산력을 요구하는 프로그램을 짜면 성능이 좋지 않음.</li></ul></li></ul><hr><h2 id="Node-js-내장-모듈-사용-방법"><a href="#Node-js-내장-모듈-사용-방법" class="headerlink" title="Node.js 내장 모듈 사용 방법"></a>Node.js 내장 모듈 사용 방법</h2><p><a href="https://nodejs.org/dist/latest-v14.x/docs/api/">[Node.js 내장 모듈 목록]</a></p><ul><li>DNS 모듈 사용법 :</li></ul><p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/dns.html">DNS | Node.js v18.2.0 Documentation</a></p><ul><li><a href="https://nodejs.org/dist/latest-v12.x/docs/api/fs.html">파일 시스템 모듈</a> → 파일을 읽거나 저장하는 기능을 구현하도록 돕는 메소드</li><li>파일 읽을 때  적합한 메소드 → <a href="https://nodejs.org/dist/latest-v12.x/docs/api/fs.html#fs_fs_readfile_path_options_callback">readFile</a></li><li>파일 저장할 때 적합한 메소드 → <a href="https://nodejs.org/dist/latest-v12.x/docs/api/fs.html#fs_fs_writefile_file_data_options_callback">writeFile</a></li></ul><h2 id="모듈을-사용하기-위해-불러오는-과정"><a href="#모듈을-사용하기-위해-불러오는-과정" class="headerlink" title="모듈을 사용하기 위해 불러오는 과정"></a>모듈을 사용하기 위해 불러오는 과정</h2><h3 id="Node-js-에서-다른-파일을-불러오기-위한-require-구문"><a href="#Node-js-에서-다른-파일을-불러오기-위한-require-구문" class="headerlink" title="Node.js 에서 다른 파일을 불러오기 위한 require 구문"></a>Node.js 에서 다른 파일을 불러오기 위한 require 구문</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 자바스크립트 코드 가장 상단에 require 구문 이용</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">// 파일 시스템 모듈 불러오기</span></span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">&#x27;dns&#x27;</span>); <span class="comment">// DNS 모듈 불러오기</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fs.readFile 메소드 등을 사용할 수 있음</span></span><br></pre></td></tr></table></figure><h3 id="3rd-party-모듈-사용하는-방법"><a href="#3rd-party-모듈-사용하는-방법" class="headerlink" title="3rd-party 모듈 사용하는 방법"></a>3rd-party 모듈 사용하는 방법</h3><p>**써드 파티 모듈(3rd-party module)**은 해당 프로그래밍 언어에서 공식적으로 제공하는 빌트인 모듈이 아닌 모든 <strong>외부 모듈</strong>을 말한다. </p><p>ex) Node.js에서 underscore는 Node.js 공식문서에 없는 모듈이기 때문에 써드 파티 모듈이라고 할 수 있음.</p><p>⇒ <strong>써드 파티 모듈을 다운</strong> 받기 위해 터미널에서 <strong>npm을 사용</strong>해야 함</p><p><strong>[ 터미널에서 underscore 모듈 설치하기 ]</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install underscore</span><br></pre></td></tr></table></figure><p>⇒ node_modules에 underscore 설치한 후, </p><p>Node.js 내장 모듈을 사용하듯 <strong>require 구문</strong>을 사용해 underscore을 사용할 수 있음</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;underscore&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.js의 3rd-party 모듈인 &#x27;underscore&#x27;사용</span></span><br></pre></td></tr></table></figure><hr><h2 id="fs-readFile-path-options-callback"><a href="#fs-readFile-path-options-callback" class="headerlink" title="fs.readFile(path, [options], callback)"></a>fs.readFile(path, [options], callback)</h2><p>메소드 fs.readFile은 비동기적으로 파일 내용 전체를 읽는다. 로컬에 존재하는 파일을 읽어온다. 이 메소드는 실행할 때 인자 세 개를 넘길 수 있다.</p><ul><li><strong>path</strong> → &lt;string&gt;, &lt;Buffer&gt;, &lt;URL&gt;, &lt;integer&gt;<ul><li>path 에는 파일 이름을 인자로 넘길 수 있다. 위의 네가지 종류 타입을 넘길 수 있지만 일반적으로는 문자열 타입으로 넘김</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ect/passwd 파일을 불러오는 예제</span></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>, ..., ...)</span><br></pre></td></tr></table></figure><ul><li><strong>options</strong> → &lt;Object&gt;, &lt;string&gt;<ul><li>대괄호로 감싼 두번째 인자 options는 선택적으로 넣거나 생략할 수 있는 인자.</li><li>객체 형태 또는 문자열 타입으로 넘길 수 있다. 문자열의 경우 인코딩을 넘긴다.</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line"><span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> <span class="comment">// UTF-8 인코딩 방식으로 열기</span></span><br><span class="line"><span class="attr">flag</span>: <span class="string">&#x27;r&#x27;</span> <span class="comment">// 읽기 위해 열기</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 옵션을 사용하여 passwd 파일을 읽는다</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>, options, ...)</span><br></pre></td></tr></table></figure><ul><li><strong>callback</strong> → &lt;Function&gt;<ul><li><strong>err</strong> → \ <Error></li><li><strong>data</strong> → &lt;string&gt; , &lt;Buffer&gt;<ul><li>콜백 함수를 전달한다. 파일을 읽은 후에 비동기적으로 실행되는 함수.</li><li>두 가지 파라미터가 존재한다. 에러가 발생하지 않으면 err ⇒ null 이 되고, data 에 문자열이너 Buffer 라는 객체가 전달된다. (data는 파일의 내용)</li></ul></li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs.readeFile 메소드로 파일의 데이터를 읽어 들인다</span></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="keyword">throw</span> err; <span class="comment">// 에러를 던짐</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h1 id="fetch를-이용한-네트워크-요청"><a href="#fetch를-이용한-네트워크-요청" class="headerlink" title="fetch를 이용한 네트워크 요청"></a>fetch를 이용한 네트워크 요청</h1><p>비동기 요청의 가장 대표적인 사례는 <strong>네트워크 요청</strong>이다. 네트워크를 통해 이뤄지는 요청은 형태가 다양하며 URL로 요청하는 경우가 가장 흔함.  </p><p>⇒ <strong>URL 요청</strong>을 가능하게 해주는 API가 <strong>fetch API</strong>이다.</p><p>포털사이트는 <strong>변하는 정보</strong>와 <strong>고정적인 정보</strong>가 따로 분리된 구성이다. <strong>최신 뉴스나 날씨 정보 등 동적으로 데이터를 받아와야 하는 정보</strong>는 해당 정보만 업데이트하기 위해 요청 API를 이용한다. 그 중 대표적인 <strong>fetch API</strong>를 이용해 <strong>해당 정보를 원격 URL로부터 불러오는 경우</strong>, <strong>원격 URL로부터 정보를 받아</strong>와서 <strong>DOM 엘리먼트를 업데이트</strong> 한다.</p><p>→ <strong>URL에 요청</strong>을 보내고 <strong>필요한 정보</strong>를 받아온다.</p><p><strong>fetch API는  특정 URL로부터 정보를 받아오는 역할</strong>을 하는데, 이 과정이 <strong>비동기</strong>로 이루어져 다소 시간이 걸릴 수 있다. 시간이 소요되는 작업을 요구할 경우에는 blocking이 발생하면 안되므로 DOM에 정보가 표시될 때 까지 로딩 창을 대신 띄우는 경우도 있다.</p><h2 id="fetch-API-사용법"><a href="#fetch-API-사용법" class="headerlink" title="fetch API 사용법"></a>fetch API 사용법</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch API는 Promise의 형식으로 이루어져 있음</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&quot;---주소---&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>()) <span class="comment">// 자체적으로 json() 메소드가 있어, 응답을 JSON 형태로 변환시킨 후 다음 Promise로 전달</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json)) <span class="comment">// 콘솔에 json을 출력</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error)); <span class="comment">// 에러가 발생한 경우, 에러를 띄운다</span></span><br></pre></td></tr></table></figure><p>→ 자세한 내용 : <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">MDN</a> 참고</p><hr><br/>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Web </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> 비동기 </tag>
            
            <tag> Node.js </tag>
            
            <tag> Fetch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>비동기 - UnderBar 라이브러리</title>
      <link href="/2022/05/18/asynchronous/"/>
      <url>/2022/05/18/asynchronous/</url>
      
        <content type="html"><![CDATA[<h1 id="비동기-UnderBar-라이브러리"><a href="#비동기-UnderBar-라이브러리" class="headerlink" title="비동기 - UnderBar 라이브러리"></a>비동기 - UnderBar 라이브러리</h1><h3 id="JS-x2F-Node-비동기"><a href="#JS-x2F-Node-비동기" class="headerlink" title="[JS&#x2F;Node] 비동기"></a>[JS&#x2F;Node] 비동기</h3><aside>💡 비동기 흐름은 callback, promsie, async/await 중 하나의 문법을 이용해 구현 가능.</aside><h3 id="Achievement-Goals"><a href="#Achievement-Goals" class="headerlink" title="Achievement Goals"></a>Achievement Goals</h3><ul><li>어떤 경우에 중첩된 callback이 발생하는지 이해</li><li>중첩된 callback의 단점과 Promise의 장점 이해</li><li>Promise 사용 패턴을 이해<ul><li>resolve, reject의 의미 &#x2F; then, catch와의 관계 이해</li><li>Promise에서 인자를 넘기는 방법</li><li>Promise.all 의 사용법</li></ul></li><li>async &#x2F; await : keyword에 대해 이해 및 작동 원리 이해</li><li>Node.js의 fs 모듈 사용법을 이해</li></ul><hr><h2 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h2><h3 id="비동기의-이해"><a href="#비동기의-이해" class="headerlink" title="비동기의 이해"></a>비동기의 이해</h3><p>커피숍에서 먼저 주문한 손님1이 커피를 받을 때까지, 줄 서 있는 손님2는 주문 불가능</p><p>→ <strong>blocking</strong> : 하나의 작업이 끝날 때까지, 이어지는 작업을 “막기”</p><p>손님2는 손님1의 커피가 나온 후, 주문 가능 → <strong>손님1의 주문 완료 시점 &#x3D; 손님2의 주문 시작 시점</strong></p><p>→ <strong>동기적(synchronous)</strong> : 작업의 시작 시점과 완료 시점이 같은 상황</p><p>주문 과정을 효율적으로 변경하기</p><ul><li>커피 주문이 blocking 되지 않고, 언제든지 주문을 받을 수 있게 한다.</li><li>커피가 완성되면 즉시 제공 : 손님1의 주문 완료 시점과 손님2의 주문 시작 시점이 같지 않아도 됨</li></ul><p>→ 이러한 합리적인 대안으로 Node.js를 non-blocking하고 비동기적(asynchronous)으로 작동하는 런타임으로 개발함.</p><p>JavaScript의 비동기적 실행(Asynchonous execution)이라는 개념은 웹 개발에서 유용</p><ul><li>백그라운드 실행, 로딩 창 등의 작업</li><li>인터넷에서 서버로 요청, 응담을 기다리는 작업</li><li>큰 용량의 파일을 로딩하는 작업</li></ul><p>⇒ 비동기적으로 작동되었을 때 효율적인 작업들</p><hr><h2 id="고차함수와-Callback"><a href="#고차함수와-Callback" class="headerlink" title="고차함수와 Callback"></a>고차함수와 Callback</h2><p>[고차함수, Higher order function]</p><ul><li><p>다른 함수를 인자로 전달받을 수 있음</p></li><li><p>다른 함수를 리턴할 수 있음</p></li><li><p>함수를 리턴하는 함수, 함수를 인자로 받는 함수 ⇒ 고차함수</p></li><li><p>고차함수는 콜백 함수와 커리 함수의 상위 개념</p><p>  콜백 함수를 전달받은 caller 함수 &#x3D; 함수 내부에서 이 콜백 함수를 호출(invoke) 가능</p></li></ul><hr><h2 id="UnderBar"><a href="#UnderBar" class="headerlink" title="UnderBar"></a>UnderBar</h2><p>: 배열, 객체를 다루는 라이브러리.</p><p> underbar 라이브러리를 구현하며 자바스크립트 내장 메소드가 어떻게 callback 함수를 활용하는지 원리 이해하기.</p><p>모티브가 되는 라이브러리로 <a href="https://underscorejs.org/">underscore.js</a>, <a href="https://lodash.com/">lodash</a> 등</p><hr><h3 id="자바스크립트-배열-내장-메소드-forEach-x2F-map-x2F-filter-x2F-reduce"><a href="#자바스크립트-배열-내장-메소드-forEach-x2F-map-x2F-filter-x2F-reduce" class="headerlink" title="# 자바스크립트 배열 내장 메소드 [forEach &#x2F; map &#x2F; filter &#x2F; reduce ]"></a># 자바스크립트 배열 내장 메소드 [forEach &#x2F; map &#x2F; filter &#x2F; reduce ]</h3><ul><li>forEach : 배열의 각 요소들을 개별적으로 반환</li><li>map : 모든 요소에게 동일한 행동 후 다시 반환</li><li>filter : 모든 요소 중 조건에 맞는 값들만 반환</li><li>reduce : 전달된 초기값을 기준으로 누적시켜 새로운 값 반환</li></ul><h3 id="callback-함수를-전달하여-사용"><a href="#callback-함수를-전달하여-사용" class="headerlink" title="# callback 함수를 전달하여 사용"></a># callback 함수를 전달하여 사용</h3><p>값으로 전달된 함수는 내부적으로 호출될 수 있기 때문에, 원래 함수의 기본적인 동작 방법을 변경할 숭 있다.</p><p>함수가 다른 함수의 인자로 사용되어 그 함수의 내용을 바꿀 수 있는 것이 콜백(callback)함수.</p><p>콜백이 비동기처리에서 사용될 때, 시간이 오래 걸리는 작업이 완료된 후에 처리해야 할 일을 콜백으로 지정하면 해당 작업이 끝났을 때 미리 등록한 작업을 실행하도록 할 수 있다.</p><h3 id="closure-함수를-리턴하여-활용"><a href="#closure-함수를-리턴하여-활용" class="headerlink" title="# closure 함수를 리턴하여 활용"></a># closure 함수를 리턴하여 활용</h3><p>내부함수가 외부함수의 내용에 접근할 수 있는 개념이다.</p><p>외부함수의 실행이 종료되어 외부함수가 소멸된 이후에도 외부함수의 범위(scope)에 접근할 수 있는 내부함수.</p><p>⇒ 자바스크립트에서 함수가 값으로 취급되어 함수를 parameter로도 받을 수 있고 [→Callback], return 할 수도 있다[→Closure].</p><h3 id="…-Spread-Syntax-를-사용하여-인자의-개수-파악-및-인자에-접근"><a href="#…-Spread-Syntax-를-사용하여-인자의-개수-파악-및-인자에-접근" class="headerlink" title="# …(Spread Syntax)를 사용하여 인자의 개수 파악 및 인자에 접근"></a># …(Spread Syntax)를 사용하여 인자의 개수 파악 및 인자에 접근</h3><ul><li>rest parameter : 개별의 요소들을 하나의 배열로 묶기 위해 사용<ul><li>매개변수 앞에 점 …을 붙여서 정의한 매개변수 ⇒ 묶인 요소들의 타입은 ‘배열’로 출력</li></ul></li><li>spread syntax : 하나의 요소를 개별의 요소들로 펼치기 위해 사용<ul><li>배열, 문자열, 객체 등 Iterable Object를 각각의 요소로 펼칠 수 있다.</li></ul></li></ul><hr><br/>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Web </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> 고차함수 </tag>
            
            <tag> 비동기 </tag>
            
            <tag> callback </tag>
            
            <tag> Promise </tag>
            
            <tag> async </tag>
            
            <tag> await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM과 HTML</title>
      <link href="/2022/05/02/dom-html/"/>
      <url>/2022/05/02/dom-html/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-x2F-브라우저-DOM-으로-HTML-조작하기"><a href="#JS-x2F-브라우저-DOM-으로-HTML-조작하기" class="headerlink" title="[JS&#x2F;브라우저] DOM 으로 HTML 조작하기"></a>[JS&#x2F;브라우저] DOM 으로 HTML 조작하기</h1><aside>🚨 CRUD(Create, Read, Update, Delete)에 집중하고, 이해하자. 이후 다양한 trivia에 대해 알아야 한다. DOM에는 HTML에 적용(APPEND)하는 메소드가 따로 있다는 것을 주의!</aside><br/><h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><ul><li>DOM을 JavaScript로 조작하여 HTML Element를 추가 &#x2F; 삭제 &#x2F; 내용 변경<ul><li>createElement - CREATE</li><li>querySelector, querySelectorAll - READ</li><li>textContent, id, classList, setAttribute - UPDATE</li><li>remove, removeChild, <code>innerHTML = “”</code>, <code>textContent = “”</code> - DELETE</li><li>appendChild - APPEND</li><li>innerHTML와 textContent의 차이</li></ul></li><li>DOM을 JavaScript로 조작하여 HTML Element를 추가 &#x2F; 삭제 &#x2F; 내용 변경<ul><li>createElement - CREATE</li><li>querySelector, querySelectorAll - READ</li></ul></li></ul><hr><br/><h2 id="CREATE-createElement"><a href="#CREATE-createElement" class="headerlink" title="CREATE -createElement"></a>CREATE -createElement</h2><p>document 객체의 createElement 메소드를 이용하여 새로운 div element 만든다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure><p>자바스크립트의 어떤 작업 결과를 담으려면, 변수를 선언하고 작업의 결과를 변수에 할당한다. 여기서 div element를 변수 tweetDiv에 할당한다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tweetDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure><p>⇒ 이렇게 생성된 tweetDiv라는 요소는 어디에 연결되지 않은 공중 부양중인 노드이다.</p><p><img src="/image/Web/domhtml1.png"></p><p> 공중에 떠있는 엘리먼트를 확인하려면 ‘APPEND’ 한다.</p><br/><hr><h2 id="APPEND-append-appendChild"><a href="#APPEND-append-appendChild" class="headerlink" title="APPEND - append, appendChild"></a>APPEND - append, appendChild</h2><p>tweetDiv 변수를 트리 구조와 연결하기 위해 append 라는 메소드를 사용해서 body에 넣는다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(tweetDiv)</span><br></pre></td></tr></table></figure><br/><hr><h2 id="READ-querySelector-querySelectorAll"><a href="#READ-querySelector-querySelectorAll" class="headerlink" title="READ - querySelector, querySelectorAll"></a>READ - querySelector, querySelectorAll</h2><p>자바스크립트에서 원시 자료형인 변수의 값을 조회하기 위해서는, 변수의 이름으로 직접 조회할 수 있다. </p><ul><li>참조 자료형인 배열 ⇒ <strong>index</strong></li><li>객체 ⇒ <strong>key</strong></li></ul><p>BUT, DOM으로 HTML 엘리먼트의 정보를 조외하기 위해서 <strong>querySelectior</strong>의 첫 번째 인자로 <strong>셀렉터(Selectior)를 전달</strong>하여 확인할 수 있다. 셀렉터로는 <strong>HTML 태그(”[태그명]”), id(”#[id명]”), class(.클래스명)</strong> 세 가지가 주로 사용.</p><p> → <strong>querySelector</strong>는 <strong>셀렉터를 조회</strong>한다는 의미를 가지고 있다. <strong>query</strong>의 의미는 <strong>질문하다</strong>라는 의미.</p><br/><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><p>querySelector에 <strong>‘.tweet’</strong>을 첫 번째 인자로 넣으면, <strong>클래스 이름이 tweet인 엘리먼트 중 첫 번째 엘리먼트</strong>를 조회 </p><p>→ 한 개</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [변수] = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.tweet&#x27;</span>)</span><br></pre></td></tr></table></figure><br/><h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h3><p><strong>여러 개의 엘리먼트를 한 번에</strong> 가져오려면 <strong>querySelectorAll</strong>을 사용한다. 조회한 HTML 엘리먼트들은 <strong>배열처럼 for문</strong>을 사용할 수 있다. 근데 이제 배열은 아닌… 배열이 아닌 배열 </p><p>→ <strong>유사 배열, 배열형 객체 &#x3D; Array-like Object</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [변수] = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.tweet&#x27;</span>)</span><br><span class="line"><span class="comment">// querySelectorAll로 클래스 이름이 tweet인 모든 html 엘리먼트를 유사 배열로 받아온다</span></span><br></pre></td></tr></table></figure><br/><h3 id="getElementById-x3D-querySelector"><a href="#getElementById-x3D-querySelector" class="headerlink" title="getElementById &#x3D; querySelector"></a>getElementById &#x3D; querySelector</h3><p><strong>get으로 시작</strong>하는 <strong>DOM 조회 메소드</strong>는 <strong>querySelector와 비슷한 역할</strong>을 하는 오래된 방식이다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> B = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#containter&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A === B) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><br/><h3 id="⇒-트리-구조에-새-엘리먼트-추가하기"><a href="#⇒-트리-구조에-새-엘리먼트-추가하기" class="headerlink" title="⇒ 트리 구조에 새 엘리먼트 추가하기"></a>⇒ 트리 구조에 새 엘리먼트 추가하기</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelectory</span>(<span class="string">&#x27;#container&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> tweetDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">container.<span class="title function_">append</span>(tweetDiv)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CREATE에서 생성한 div 엘리먼트를 container의 맨 마지막 자식 엘리먼트로 추가한다.</span></span><br></pre></td></tr></table></figure><p><img src="/image/Web/domhtml2.png"></p><br/><hr><h2 id="UPDATE-textContent-classList-add"><a href="#UPDATE-textContent-classList-add" class="headerlink" title="UPDATE - textContent, classList.add"></a>UPDATE - textContent, classList.add</h2><p><strong>UPDATE</strong>는 기존에 <strong>빈 div 태그를 업데이트</strong>한다. <strong>textContent</strong>를 사용하여 <strong>빈 div 엘리먼트에 문자열을 입력</strong>한다</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oneDiv) <span class="comment">//&lt;div&gt;&lt;/div&gt;</span></span><br><span class="line">oneDiv.<span class="property">textContent</span> = <span class="string">&#x27;dev&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oneDiv) <span class="comment">//&lt;div&gt;dev&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// textContent를 이용해 문자열을 입력</span></span><br><span class="line"></span><br><span class="line">oneDiv.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;tweet&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oneDiv) <span class="comment">// &lt;div class=&quot;tweet&quot;&gt;dev&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// classList.add를 이용해 &#x27;tweet&#x27; 클래스를 추가</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#container&#x27;</span>)</span><br><span class="line">container.<span class="title function_">append</span>(oneDiv)</span><br><span class="line"><span class="comment">// append를 이용해 container의 자식 요소에 oneDiv를 추가</span></span><br></pre></td></tr></table></figure><p>*class, id 외의 다른 attribute를 추가하기</p><p>⇒ MDN에서 <strong>setAttribute</strong> 메소드 검색</p><br/><hr><h2 id="DELETE-remove-removeChild"><a href="#DELETE-remove-removeChild" class="headerlink" title="DELETE - remove, removeChild"></a>DELETE - remove, removeChild</h2><p>CRUD의 Delete, 삭제하는 법.</p><br/><h3 id="remove-메소드-삭제할-엘리먼트-위치를-알고-있을-때"><a href="#remove-메소드-삭제할-엘리먼트-위치를-알고-있을-때" class="headerlink" title="remove 메소드 : 삭제할 엘리먼트 위치를 알고 있을 때"></a>remove 메소드 : 삭제할 엘리먼트 위치를 알고 있을 때</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#container&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> tweetDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">container.<span class="title function_">append</span>(tweetDiv)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append 했던 엘리먼트를 삭제</span></span><br><span class="line">tweetDiv.<span class="title function_">remove</span>()</span><br></pre></td></tr></table></figure><br/><h3 id="innerHTML-여러-개의-자식-엘리먼트를-지울-때"><a href="#innerHTML-여러-개의-자식-엘리먼트를-지울-때" class="headerlink" title="innerHTML : 여러 개의 자식 엘리먼트를 지울 때"></a>innerHTML : 여러 개의 자식 엘리먼트를 지울 때</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#container&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// id가 contianer인 엘리먼트 아래의 모든 엘리먼트를 지우기</span></span><br></pre></td></tr></table></figure><p>→ innerHTML을 이용하면 간편하지만 보안 문제를 가지고 있어 다른 메소드를 사용함</p><br/><h3 id="removeChild-자식-엘리먼트를-지정해서-삭제하는-메소드"><a href="#removeChild-자식-엘리먼트를-지정해서-삭제하는-메소드" class="headerlink" title="removeChild : 자식 엘리먼트를 지정해서 삭제하는 메소드"></a>removeChild : 자식 엘리먼트를 지정해서 삭제하는 메소드</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#container&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> (container.<span class="property">firstChild</span>) &#123;</span><br><span class="line">container.<span class="title function_">removeChild</span>(container.<span class="property">firstChild</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 모든 자식 엘리먼트를 삭제하기 위해서 반복문[while, for, etc.] 활용</span></span><br><span class="line"><span class="comment">// 자식 엘리먼트가 남아있지 않을 때까지 첫번째 자식 엘리먼트를 삭제하는 코드</span></span><br></pre></td></tr></table></figure><br/><hr><h3 id="심화로-공부할-것"><a href="#심화로-공부할-것" class="headerlink" title="심화로 공부할 것."></a>심화로 공부할 것.</h3><ul><li>element &#x2F; node 차이<ul><li>difference between element and node in javascript dom</li></ul></li><li>children &#x2F; childNodes 차이<ul><li>difference between children and childNodes in javascript dom</li></ul></li><li>removeChild &#x2F; remove 차이<ul><li>difference between removeChild and remove in javascript dom</li></ul></li><li>forEach는 되는데, reduce는 안되는 이유<ul><li>why array method is not working on nodelist</li></ul></li><li>유사 배열에서 배열로 바꾸는 방법<ul><li>how to convert nodelist into javascript array</li></ul></li></ul><hr><br/>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Web </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> Dom </tag>
            
            <tag> HTML </tag>
            
            <tag> CRUD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM의 이해</title>
      <link href="/2022/05/02/dom/"/>
      <url>/2022/05/02/dom/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-x2F-브라우저-DOM-이해하기"><a href="#JS-x2F-브라우저-DOM-이해하기" class="headerlink" title="[JS&#x2F;브라우저] DOM 이해하기"></a>[JS&#x2F;브라우저] DOM 이해하기</h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM ?"></a>DOM ?</h2><p>DOM은 Document Object Model의 약자로, HTML 요소를 Object(JavaScript Object)처럼 조작할 수 있는 모델이다. <strong>자바스크립트를 사용할 수 있으면, DOM으로 HTML을 조작</strong>할 수 있다.</p><p>HTML을 조작할 수 있다는 것은 DOM을 위해 여러 뛰어난 웹 개발자들이 모여 HTML을 철저히 분석했다. 분석한 내용으로 <strong>아주 작은 부분까지 접근할 수 있는 구조</strong>(Model; Structure)을 만들어냈다. 이렇게 만들어진 구조를 이용하여 <strong>HTML로 구성된 웹 페이지를 동적으로 움직이게</strong> 만들 수 있다. 앞서 학습한 조건문과 반복문, 배열, 객체를 활용하면 SNS에서 새롭게 생성되는 게시물을 저장하고 분류하는 작업을 할 수 있다.</p><p><a href="https://youtu.be/p5vI5OrLJU8">자바스크립트는 다양한 일</a>을 할 수 있지만 웹 페이지를 제어하기 위한 목적으로 사용되었다. DOM을 학습하여 자바스크립트로 홈페이지를 다이나믹하게 만든다.</p><br/><hr><h3 id="자바스크립트로-할-수-있는-것들-첨부-동영상"><a href="#자바스크립트로-할-수-있는-것들-첨부-동영상" class="headerlink" title="자바스크립트로 할 수 있는 것들 [첨부 동영상]"></a>자바스크립트로 할 수 있는 것들 [첨부 동영상]</h3><p><a href="https://youtu.be/p5vI5OrLJU8">자바스크립트로 할 수 있는 7가지</a></p><br/><h2 id="HTML에-JavaScript-적용하기"><a href="#HTML에-JavaScript-적용하기" class="headerlink" title="HTML에 JavaScript 적용하기"></a>HTML에 JavaScript 적용하기</h2><h3 id="script-태그-이용하기"><a href="#script-태그-이용하기" class="headerlink" title="script 태그 이용하기"></a>script 태그 이용하기</h3><p><img src="/image/Web/dom1.png"></p><p>웹 브라우저가 작성된 코드를 해석하는 과정에서 <code>&lt;script&gt;</code> 요소를 만나면, HTML 해석을 잠시 멈추고 스크립트 요소를 먼저 실행한다. <code>&lt;script&gt;</code> 요소는 등장과 함께 실행 된다.</p><br/><h3 id="HTML-구조-분석"><a href="#HTML-구조-분석" class="headerlink" title="HTML 구조 분석"></a>HTML 구조 분석</h3><p>자바스크립트에서 <strong>DOM은 document 객체에 구현</strong>되어 있다. 브라우저에서 작동되는 자바스크립트 코드에서 document 객체를 조회할 수 있다.</p><p>→ 크롬 <strong>개발자도구</strong>에서 <strong>document.body 조회</strong>하기</p><p><img src="/image/Web/dom2.png"></p><p>DOM 구조를 조회할 때 <strong>console.dir</strong>은 console.log와 달리 <strong>객체의 모습</strong>으로 출력. </p><br/><h3 id="1-자식-엘리먼트-찾기"><a href="#1-자식-엘리먼트-찾기" class="headerlink" title="#1. 자식 엘리먼트 찾기"></a>#1. 자식 엘리먼트 찾기</h3><p><strong>console.dir</strong>(document.body)의 출력된 객체에서, <strong>children(자식 엘리먼트) 속성</strong>을 찾을 수 있다. 혹은 <strong>document.body.children</strong> 으로 바로 조회할 수 있다.</p><br/><h3 id="2-부모-엘리먼트-찾기"><a href="#2-부모-엘리먼트-찾기" class="headerlink" title="#2. 부모 엘리먼트 찾기"></a>#2. 부모 엘리먼트 찾기</h3><p><img src="/image/Web/3.png"></p><p>id가 news-contents인 <strong>div</strong> 엘리먼트의 <strong>부모 엘리먼트</strong>는 <strong>body</strong> 엘리먼트이다. <strong>document.body.children</strong>의 <strong>첫 번째 엘리먼트</strong>를 조회한다. 이때 반복적으로 document.body를 찾는 것 보다 <strong>변수를 선언</strong>하여 <strong>정보를 저장</strong>하고, <strong>참조</strong>하여 사용한다.</p><br/><h3 id="3-DOM-순회하기"><a href="#3-DOM-순회하기" class="headerlink" title="#3. DOM 순회하기"></a>#3. DOM 순회하기</h3><p><img src="/image/Web/dom3.png"></p><p>DOM 구조는 회사의 조직도와 비슷함. <strong>가장 상위에 있는 요소</strong>와 <strong>아래에 여러 구성요소</strong>가 서로 <strong>부모-자식 관계</strong>를 가지고 있다. 이런 자료 구조를 <strong>”트리 구조”</strong>.</p><p>⇒ 트리 구조는 <strong>하나의 부모가 자식을 여럿</strong> 가지는 구조가 <strong>반복.</strong> </p><p>⇒ So, <strong>부모가 가진 하나~여러 자식 엘리먼트를 조회</strong>하는 코드 작성시, <strong>여러 번 반복 실행하는 코드가 필요</strong>함.</p><br/><h3 id="엘리먼트를-조회하는-코드-작성을-위한-수도-코드"><a href="#엘리먼트를-조회하는-코드-작성을-위한-수도-코드" class="headerlink" title="엘리먼트를 조회하는 코드 작성을 위한 수도 코드"></a>엘리먼트를 조회하는 코드 작성을 위한 수도 코드</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">consoleLogAllElement</span>(<span class="params">element</span>)&#123;</span><br><span class="line"><span class="comment">// nav의 class 이름을 console.log</span></span><br><span class="line"><span class="comment">// nav의 자식 엘리먼트가 있는지 검색 (logo, menu-wrapper)</span></span><br><span class="line">  <span class="comment">//logo의 class 이름을 console.log </span></span><br><span class="line">  <span class="comment">//logo의 자식 엘리먼트가 있는지 검색 (없음)</span></span><br><span class="line">  <span class="comment">//menu-wrapper의 class 이름을 console.log</span></span><br><span class="line">  <span class="comment">//menu-wrapper의 자식 엘리먼트가 있는지 검색 (menu, menu, menu, profile-photo)</span></span><br><span class="line">    <span class="comment">//첫 번째 menu의 class 이름을 console.log</span></span><br><span class="line">    <span class="comment">//첫 번째 menu의 자식 엘리먼트가 있는지 검색 (없음)</span></span><br><span class="line">    <span class="comment">//두 번째 menu의 class 이름을 console.log</span></span><br><span class="line">    <span class="comment">//두 번째 menu의 자식 엘리먼트가 있는지 검색 (없음)</span></span><br><span class="line">    <span class="comment">//세 번째 menu의 class 이름을 console.log</span></span><br><span class="line">    <span class="comment">//세 번째 menu의 자식 엘리먼트가 있는지 검색 (없음)</span></span><br><span class="line">    <span class="comment">//profile-photo의 class 이름을 console.log</span></span><br><span class="line">    <span class="comment">//profile-photo의 자식 엘리먼트가 있는지 검색 (없음)</span></span><br><span class="line"> <span class="comment">//자식 엘리먼트를 모두 탐색했음으로, 함수 실행이 종료</span></span><br><span class="line"><span class="comment">//자식 엘리먼트를 모두 탐색했음으로, 함수 실행이 종료</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><br/>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Web </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> Dom </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Work Flow</title>
      <link href="/2022/04/29/git/"/>
      <url>/2022/04/29/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Git"><a href="#Linux-Git" class="headerlink" title="Linux + Git"></a>Linux + Git</h1><p>개발에도 코드 수정을 위해 이전에 작성한 내용을 보존해 주는 버전 관리 시스템(Version Control System)이 필요. 이 중 가장 강력한 도구 Git을 학습하며, 현업에서의 버전 관리 및 협업 기본을 익혀 오픈소스 생태계 기여를 목표로 함.</p><br/><hr><h2 id="버전-관리"><a href="#버전-관리" class="headerlink" title="버전 관리?"></a>버전 관리?</h2><ol><li>파일 변경시 변경 이력을 저장함.</li><li>변경 이력을 바탕으로 이전 버전으로 돌아갈 수 있음.</li><li>변경 사항 저장시 코멘트 작성을 통해 어떤 변경 사항이 발생했는지 알기 쉬움.</li><li>Git으로 관리하는 파일은 여러 원격 저장소를 이용하여 협업에 좋음.</li><li>같은 맥락으로 백업용으로도 좋음.</li></ol><p><img src="/image/Web/gitflow.png" alt="git flow"></p><br/><h2 id="Git"><a href="#Git" class="headerlink" title="Git ?"></a>Git ?</h2><p>코드를 효율적으로 관리하기 위해서 개발된 <strong>분산형 버전 관리 시스템</strong>. </p><p>날짜별로 어떤 파일이 어떤 변경이 있었는지 확인 가능. 특정 시점에 생성된 백업 복사본을 스냅샷이라 하는데 <strong>스냅샷을 만드는 작업</strong>을 <strong>commit</strong> 이라고 함. commit 기능으로 변경 사항에 대한 스냅샷 생성, 이전 기록들의 추적 가능.</p><p>→ Git에서 소스 코드 변경 이력을 확인할 수 있고, 특정 시점에 저장된 버전과 비교 혹은 해당 시점으로 되돌아갈 수 있음.</p><br/><h3 id="Git-x2F-Github"><a href="#Git-x2F-Github" class="headerlink" title="Git &#x2F; Github"></a>Git &#x2F; Github</h3><ul><li><strong>Git</strong><ul><li>소스 코드 기록을 관리하고 추적할 수 있는 버전 관리 시스템</li></ul></li><li><strong>Github</strong><ul><li>Git Repository를 관리할 수 있는 클라우드 기반 서비스</li></ul></li></ul><p>⇒ Git으로 버전을 관리하는 폴더로 Github을 통해 여러 사람들이 공유&amp;접근.</p><br/><h2 id="Github"><a href="#Github" class="headerlink" title="Github ?"></a>Github ?</h2><p>내 컴퓨터에서 <strong>Git으로 관리하는 프로젝트를 올려둘 수 있는 사이트</strong>. </p><p><strong>오픈 소스</strong>(소스 코드가 공개된 소프트웨어)는 누구나 자유롭게 해당 기능을 <strong>추가</strong>하고 <strong>개선</strong>할 수 있으며, 작업에 **기여(contribute)**함. 해당 소스코드의 기여자들(contributors)과 수정사항 commit 기록 및 변경된 코드 확인 가능.</p><h3 id="Git-repository"><a href="#Git-repository" class="headerlink" title="Git repository"></a>Git repository</h3><p>작업중인 소스 코드 폴더를 <strong>버전 관리 하기 위해서 내 폴더를 Git의 관리 하</strong>에 두는데, 이러한 폴더를 Git repository 라고 함. Git repository는 두 종류의 저장소 제공.</p><ul><li><strong>Local Repository</strong><ul><li>나 <strong>혼자 작업</strong>할 때 사용하는 저장소</li><li>내 컴퓨터, 내 개인 전용 저장소</li></ul></li><li><strong>Remote Repository</strong><ul><li>내 작업 코드를 공유하기 위해 업로드하여 <strong>여러 사람과 공유</strong>하는 저장소</li><li>원격 온라인 서버 상의 저장소</li></ul></li></ul><p>⇒ 다른 사람이 올린 Remote Repository 소스 코드를 내 Local Repository 로 가져올 수 있음.</p><h3 id="Fork-x2F-Clone"><a href="#Fork-x2F-Clone" class="headerlink" title="Fork &#x2F; Clone"></a>Fork &#x2F; Clone</h3><p>온라인상에 올라온 오픈 소스 프로젝트에 기여(contribute) 하기 위해서 해당 프로젝트 소스 코드의 <strong>원격 저장소를 내 원격 저장소로 가지고 오는 작업</strong>이 <strong>Fork.</strong></p><p>→ Fork 후, <strong>내 Remote Repository에 해당 프로젝트의 소스 코드를 옮겨온 상태</strong>에서 코드를 수정을 하려면 <strong>내 컴퓨터로 가져오는 작업</strong>이 필요함. 이 과정은 <strong>Clone</strong>. Remote Repository에 있는 코드를 Clone 해서 내 컴퓨터(Local Repository)로 이동.</p><p>→ 로컬(내 컴퓨터)에서 소스코드 변경 작업 후, <strong>변경 내용을 commit</strong>을 통해 저장하고 <strong>Remote Repository로 올려주는 작업</strong>이 필요함. 이 과정은 <strong>Push</strong>. Local Repository에 기록해 놓은 commit을 Remote Repository로 업로드함.</p><p>→ Push 완료 후, Github의 <strong>Pull Request</strong> 기능으로 내가 <strong>변경한 코드를 반영할지 여부에 대해 요청</strong> 가능.</p><p>→ Local Repository에서 변경 사항을 Remote Repository 로 업로드하기 위해 Push를 사용. 반대의 경우, <strong>Remote Repository에서 변경 사항</strong>이 있을 때 <strong>Local Repository 로 가져오는 Pull</strong> 작업도 가능.</p><br/><hr><h2 id="Git-설치-macOS"><a href="#Git-설치-macOS" class="headerlink" title="Git 설치 [macOS]"></a>Git 설치 [macOS]</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 설치</span></span><br><span class="line">git</span><br><span class="line"><span class="comment">## =&gt; xcode select 설치 여부 =&gt; 설치</span></span><br><span class="line"><span class="comment"># 다시 git 명령</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## git 버전 확인</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><br/><h2 id="Git-환경-설정"><a href="#Git-환경-설정" class="headerlink" title="Git 환경 설정"></a>Git 환경 설정</h2><h3 id="사용자-정보"><a href="#사용자-정보" class="headerlink" title="사용자 정보"></a>사용자 정보</h3><p>: 사용자 이름, 이메일 주소 설정. 기록된 정보를 Git 커밋 내역에 기록.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;나의 사용자 이름&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;내 이메일 주소&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --global 옵션으로 설정하면 사용자 홈에 저장되어 git 설정 처음에만 입력, 사용자 이름 및 이메일 변경시 다시 입력해야 함.</span></span><br></pre></td></tr></table></figure><br/><h3 id="에디터-설정"><a href="#에디터-설정" class="headerlink" title="에디터 설정"></a>에디터 설정</h3><p>: Git에서 커밋 메시지를 기록할 때, merge commit 확인 메시지가 나올 때 텍스트 에디터로 vi가 열리는데, nano로 변경해도 됨.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor nano</span><br></pre></td></tr></table></figure><h3 id="Git-최초-설정"><a href="#Git-최초-설정" class="headerlink" title="Git 최초 설정"></a>Git 최초 설정</h3><p><a href="https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EC%B5%9C%EC%B4%88-%EC%84%A4%EC%A0%95">Git - Git 최초 설정</a></p><br/><hr><h2 id="SSH-등록"><a href="#SSH-등록" class="headerlink" title="SSH 등록"></a>SSH 등록</h2><p>HTTPS로 git을 사용할 때에는 토큰을 발행하여 접속해야함.</p><p>ssh는 Secure shell의 줄임말, 보안이 강화된 shell 접속을 뜻한다. CLI 환경(터미널)에서 다른 PC에 접속하거나 요청할 때 사용, 비대칭키를 이용해 사용자를 인증.</p><h3 id="SSH-키-생성"><a href="#SSH-키-생성" class="headerlink" title="SSH 키 생성"></a>SSH 키 생성</h3><p>비대칭키로 구성되며, 두 개의 키가 서로 대칭이 되지 않는 형태로 존재함. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh 키 페어 생성</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="comment">## 이후 enter 키 반복</span></span><br><span class="line"><span class="comment"># ~/.ssh./ 경로에 두 파일 id_rsa 와 id_rsa.pub 키 페어 생성</span></span><br><span class="line"><span class="comment">## id_rsa.pub = 누구에게나 공개해도 되는 공개키(Public Key)</span></span><br><span class="line"><span class="comment">## id_rsa = 비공개로 나만 보관하는 키, 개인키(Private Key) = 비밀키(Secret Key)</span></span><br></pre></td></tr></table></figure><p>⇒ 생성된 SSH 키 페어 중 <strong>공개키</strong>를 복사하여 <strong>gitub에 등록</strong></p><br/><h3 id="공개키-Public-Key-복사"><a href="#공개키-Public-Key-복사" class="headerlink" title="공개키(Public Key) 복사"></a>공개키(Public Key) 복사</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh 출력</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment">## 공개키 복사</span></span><br></pre></td></tr></table></figure><br/><h3 id="Github에-공개키-등록"><a href="#Github에-공개키-등록" class="headerlink" title="Github에 공개키 등록"></a>Github에 공개키 등록</h3><ul><li>브라우저로 Github 이동 &gt; 로그인</li><li>우측 상단 프로필 클릭 &gt; Settings</li><li>좌측 네비게이션 &gt; SSH and GPG keys</li><li>SSH keys &gt; [버튼] New SSH Key</li><li>키 구분을 위해 임의의 타이틀 작성 &gt; Key에 공개키 붙여넣기 &gt; [버튼] Add SSH Key</li><li>Confirm access에서 Github 로그인 비밀번호 입력 후, SSH key 등록 승인</li></ul><br/><hr><h2 id="Github-CLI-사용-인증-과정"><a href="#Github-CLI-사용-인증-과정" class="headerlink" title="Github CLI 사용 인증 과정"></a>Github CLI 사용 인증 과정</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Github CLI 설치</span></span><br><span class="line">brew install gh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 로그인 시도</span></span><br><span class="line">gh auth login</span><br></pre></td></tr></table></figure><blockquote><ul><li>화살표 키로 다음 항목 선택 &gt; Enter</li></ul><p>? What accout do you want to log into? <a href="http://github.com/">GitHub.com</a><br>? What is your preferred protocol for Git Operations? HTTPS<br>? Authenticate Git with your GitHub credentials? Yes<br>? How would you like to authenticate GitHub CLI? Login with a web browser</p></blockquote><blockquote><p><strong>one-time code</strong> &gt; Enter &gt; <strong>Device Activation 에 입력</strong></p></blockquote><br/><hr><h2 id="혼자-workflow"><a href="#혼자-workflow" class="headerlink" title="혼자 workflow"></a>혼자 workflow</h2><ol><li>Remote의 다른 Repository에서 Fork를 해서 Remote에 있는 내 Repository에 가지고 옴.</li><li>해당 코드 수정을 위해 내 컴퓨터로 가져오는 작업이 또 필요. 내 컴퓨터에서 작업을 하기 위해 clone.</li><li>내 컴퓨터의 작업 공간(work space) 에서 작업에 들어간 파일들을 git의 관리하에 있는 상태로 올려줌. 이 영역이 staging area. 즉, staging area에 들어오지 않은 파일은 unstaged 혹은 untracked file 이라 하며, staging area에 있는 파일들은 staged 된 파일이라함. </li><li>staging area에 들어온 파일들은 commit이 가능. commit을 한 후, 내 remote repository에 push 해서 commit 기록을 remote 에도 남길 수 있음.</li><li>push 완료 후, remote의 원래 레파지토리에 pull request를 보내 Remote Repository로 내가 수정한 코드를 업로드 가능.</li></ol><br/><hr><h2 id="함께-workflow"><a href="#함께-workflow" class="headerlink" title="함께 workflow"></a>함께 workflow</h2><ol><li>내 컴퓨터에서 생성한 디렉토리를 init 명령어를 통해 Git의 관리하에 들어가게 만듦.</li><li>내 컴퓨터의 Git 디렉토리를 Remote Repository와 연결.</li><li>pair의 변경 사항과 나의 변경 사항을 Remote Repository를 통해서 공유.</li></ol><ul><li>내 컴퓨터의 디렉토리를 Git Repo로 변환, Git의 관리하에 두기.<ul><li><strong>git init</strong><ul><li>Git Repository로 변환하거나 새로운 Repository를 초기화</li></ul></li><li>⇒ Local Repo 생성</li></ul></li><li>Local Repo와 Remote Repo 연결 작업<ul><li><strong>git remote add</strong></li><li>git remote add origin &lt;내 Repository 주소&gt;<ul><li>나의 Remote Repo에 연결</li></ul></li><li>git remote add &lt;상대 Repo 이름&gt; &lt;상대방 Repository 주소&gt;<ul><li>Pair의 Remote Repo에 연결하여 Github Repo를 함께 공유</li></ul></li></ul></li><li>Local Repo와 연결된 모든 Remote Repo 리스트 확인<ul><li><strong>git remote -v</strong></li></ul></li><li><strong>git pull &lt;상대 Repo 이름&gt; &lt;branch 명&gt;</strong><ul><li>페어가 master branch에 올려둔 Remote Repo의 작업 코드 받아오기<ul><li>git pull pair master</li><li>⇒ 받아온 내용은 자동으로 merge(병합)</li></ul></li><li><strong>git status</strong><ul><li>병합 실패한 파일의 충돌 확인</li><li>Accept Current Change : 수정한 내용으로 파일에 반영</li><li>Accept Incoming Change : Remote Repo의 내용으로 반영</li><li>Accept Both Changes : 변경 사항 모두를 반영</li><li>⇒ Remote Repo에 업로드를 위해서 staging area에 파일을 추가<ul><li>git add</li><li>git commit</li><li>git push</li></ul></li></ul></li></ul></li></ul><br/><hr><br/>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Web </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux / Git</title>
      <link href="/2022/04/29/linux-git/"/>
      <url>/2022/04/29/linux-git/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-x2F-Git-기초"><a href="#Linux-x2F-Git-기초" class="headerlink" title="Linux &#x2F; Git 기초"></a>Linux &#x2F; Git 기초</h1><aside>🚨 **Linked list** : 기본적으로 알아야 하는 CLI 명령어 / 패키지와 패키지 매니저 / nvm, node.js, npm / Sprint - 짝수 생성기</aside><h3 id="프롬프트-Prompt"><a href="#프롬프트-Prompt" class="headerlink" title="프롬프트(Prompt)"></a>프롬프트(Prompt)</h3><p>터미널은 CLI(Command-Line Interface)이다. 입력하는 글자와 출력되는 글자로 컴퓨터와 소통 할 수 있다.</p><p>키보드의 입력을 확인하고 편집할 수 있는 한 줄의 공간을 프롬프트라고 한다.</p></br><h1 id="리눅스-터미널-기본적인-명령어"><a href="#리눅스-터미널-기본적인-명령어" class="headerlink" title="리눅스 터미널 기본적인 명령어"></a>리눅스 터미널 기본적인 명령어</h1><h3 id="리눅스-터미널에서-명령-실행하기"><a href="#리눅스-터미널에서-명령-실행하기" class="headerlink" title="리눅스 터미널에서 명령 실행하기"></a>리눅스 터미널에서 명령 실행하기</h3><ul><li><code>pwd</code> : 현재 위치를 확인</li><li><code>mkdir</code> : 새로운 폴더를 생성</li><li><code>ls</code> : 폴더나 파일의 목록을 출력</li><li><code>open</code> : 현재 폴더를 파일 탐색기로 열기</li><li><code>cd</code> : 폴더에 진입<ul><li>. : 현재 폴더</li><li>.. : 현재 폴더보다 앞에 있는 폴더</li></ul></li><li><code>cat</code> : 파일의 내용을 터미널에 출력</li><li><code>touch</code> : 새로운 파일을 생성</li><li><code>rm</code> : 폴더나 파일을 삭제</li><li><code>mv</code> : 폴더나 파일의 위치를 이동하거나, 이름을 변경<ul><li>mv [폴더나 파일의 이름] [도착 폴더의 이름]</li><li>mv [파일의 이름] [변경할 파일 이름]</li></ul></li><li><code>cp</code> : 폴더나 파일을 복사<ul><li>cp [원본 파일 이름] [복사할 파일 이름]</li></ul></li><li><code>sudo</code> : 관리자 권한을 이해</li><li><code>/</code> : 루트 디렉토리</li><li><code>~</code> : 홈 디렉토리</li></ul></br><h3 id="절대-경로-x2F-상대-경로"><a href="#절대-경로-x2F-상대-경로" class="headerlink" title="절대 경로 &#x2F; 상대 경로"></a>절대 경로 &#x2F; 상대 경로</h3><aside>💡 절대 경로와 상대 경로의 차이</aside><ul><li>절대 경로의 시작이 루트 디렉토리( &#x2F; )인 것을 이해할 수 있다.</li></ul><p>: 절대 경로는 명령어 pwd로 확인할 수 있다</p><p>: 절대 경로는 기준점으로부터의 절대적인 위치를 나타내는데, 이 기준점을 루트폴더( &#x2F; )라고 한다. 특정 폴더나 파일이 루트폴더로부터 어떤 폴더로 진입하는 경우 만날 수 있는지.</p><ul><li>상대 경로의 시작이 현재 디렉토리( . )인 것을 이해할 수 있다.</li></ul><p>: 상대 경로는 현재 위치로부터 상대적인 위치를 나타낸다.</p><p>: 상대 경로는 특정 폴더 또는 파일의 위치를 현재 위치를 기준점으로 나타내는데, 현재 위치한 폴더는 점( . ), 상위 폴더는 두 개의 점( .. )으로 표현.</p><p>: ls를 통해 확인되는 폴더나 파일은 상대 경로로써 .&#x2F; (&#x3D; 현재 폴더 아래 라는 뜻)을 붙여 표현할 수 있다.</p></br><h3 id="ls-명령어-설명-첨부"><a href="#ls-명령어-설명-첨부" class="headerlink" title="ls 명령어 설명 첨부"></a>ls 명령어 설명 첨부</h3><ul><li>ls -l : 옵션 l은 폴더나 파일의 포맷을 전부 표현하라는 의미</li><li>ls -a : “all”의 함축어, 숨어있는 폴더나 파일을 포함한 모든 항목을 터미널에 출력</li><li>ls -la</li></ul></br><h3 id="cp-폴더나-파일을-복사"><a href="#cp-폴더나-파일을-복사" class="headerlink" title="cp : 폴더나 파일을 복사"></a>cp : 폴더나 파일을 복사</h3><p>*현재 위치는 ~를 대신해 &#x2F;Users&#x2F;[username] (macOS)로 나타남</p><p><code>cp [원본 파일 이름] [복사할 파일 이름]</code></p><p><code>cp -rf [원본 폴더 이름] [복사할 폴더 이름]</code></p></br><h3 id="관리자-root-권한"><a href="#관리자-root-권한" class="headerlink" title="관리자(root) 권한"></a>관리자(root) 권한</h3><p>절대 경로의 기준점인 루트폴더(&#x2F;)는 리눅스의 관리자 영역이다. 일반 사용자의 권한으로는 어떤 폴더나 파일도 생성, 변경, 삭제할 수 없다.</p><p>Linux 관리자의 특징은 어떤 일이 있어도 일반 사용자에게 관리자 권한(&#x3D;루트 권한)을 완전하게 넘기지 않는다. 프로그램을 설치, 변경 또는 삭제할 수 있는 관리자 권한만 전달한다. 사용자와 관리자를 명확히 분리 → 사용자의 실수로 발생하는 시스템 에러로부터 운영체제를 보호한다.</p><p>루트폴더로 이동하여 명령어  mkdir을 이용해 폴더를 생성하면  “Read-only file system” 이라는 에러를 만나는데, 읽기전용이라는 말은 폴더나 파일을 생성, 변경, 삭제할 수 없다는 의미이다.</p><p>*현재 로그인된 사용자를 확인하는 명령어 : <code>whoami</code></p><p>*사용자 폴더의 경로(Path)는 <del>&#x2F; 로 표시된다. 물결기호(</del>)는 루트폴더(&#x2F;)로부터 사용자 폴더(username)까지의 경로를 축약한 형태</p><p>사용자가 새로운 프로그램을 설치하거나 변경 또는 삭제할 때에 사용자가 관리자 권한을 이요할 수 있는 명령어로  sudo를 사용한다.</p><h3 id="sudo-관리자-권한을-획득하는-명령어"><a href="#sudo-관리자-권한을-획득하는-명령어" class="headerlink" title="sudo : 관리자 권한을 획득하는 명령어"></a>sudo : 관리자 권한을 획득하는 명령어</h3><p>명령어 ls -l 을 통해 특정 폴더나 파일이 사용자 또는 관리자의 소유로 생성되었는지 확인할 수 있다. </p><p><code>sudo mkdir [생성할 폴더명]</code></p><p>명령어 sudo를 이용해 생성한 폴더의 소유자는 루트이다. 사용자 권한이 아닌 관리자 권한으로 생성되었다는 뜻이다.</p></br><hr><h2 id="텍스트-에디터-nano-사용법"><a href="#텍스트-에디터-nano-사용법" class="headerlink" title="텍스트 에디터 nano 사용법"></a>텍스트 에디터 nano 사용법</h2><p>CLI의 유명한 에디터 <a href="https://nolboo.kim/blog/2016/11/15/vim-for-beginner/">vim(vi)</a>, 가장 쉬운 에디터 <a href="https://www.nano-editor.org/">nano</a>.</p></br><h3 id="nano-실행"><a href="#nano-실행" class="headerlink" title="nano 실행"></a>nano 실행</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code hello.js <span class="comment"># hello.js를 VS Code에서 열기.</span></span><br><span class="line"></span><br><span class="line">nano hello.js <span class="comment"># hello.js를 nano에서 열기.</span></span><br><span class="line">nano <span class="comment"># 그냥 실행하기</span></span><br></pre></td></tr></table></figure></br><h3 id="파일-열기"><a href="#파일-열기" class="headerlink" title="파일 열기"></a>파일 열기</h3><p>단축키 <strong>^R (ctrl+R키)</strong></p><p>**^T (ctrl+T키)**를 누른 후 <strong>화살표키</strong>를 이용해 파일 및 디렉토리를 탐색한 후 불러오기</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano 파일이름 <span class="comment"># 터미널에서 파일을 지정해서 열기</span></span><br></pre></td></tr></table></figure></br><h3 id="파일-편집-후-종료"><a href="#파일-편집-후-종료" class="headerlink" title="파일 편집 후 종료"></a>파일 편집 후 종료</h3><p>**^X (ctrl+X)**를 누르면 다음과 같은 프롬프트가 등장.</p><p>Save modified buffer (ANSWERING “No” WILL DESTROY CHANGES) ?</p><p>키보드의 Y와 N을 눌러서 저장 여부를 결정.</p></br><h3 id="파일-저장"><a href="#파일-저장" class="headerlink" title="파일 저장"></a>파일 저장</h3><p><strong>^0 WriteOut</strong>을 이용하면 해당 내용을 파일에 저장하는 단축키.</p></br><hr><h2 id="패키지와-패키지-매니저"><a href="#패키지와-패키지-매니저" class="headerlink" title="패키지와 패키지 매니저"></a>패키지와 패키지 매니저</h2><h3 id="MacOS-패키지-매니저"><a href="#MacOS-패키지-매니저" class="headerlink" title="[MacOS 패키지 매니저]"></a>[MacOS 패키지 매니저]</h3><ul><li><strong>brew update</strong></li><li><strong>brew outdated</strong></li><li><strong>brew upgrade</strong></li><li><strong>brew info</strong></li><li><strong>brew install</strong></li><li><strong>brew list</strong></li><li><strong>brew uninstall</strong></li></ul></br><hr><h3 id="JavaScript-런타임-runtime"><a href="#JavaScript-런타임-runtime" class="headerlink" title="JavaScript 런타임(runtime)"></a>JavaScript 런타임(runtime)</h3><p>⇒ 크롬, 사파리 같은 <strong>앱 브라우저</strong></p></br><h3 id="런타임"><a href="#런타임" class="headerlink" title="런타임?"></a>런타임?</h3><p>: <strong>프로그래밍 언어가 실행되는 환경</strong></p><p>프로그래밍 언어가 구동되는 환경이다. 어떤 프로그램이 동작할 때, 프로그램이 동작하는 곳이다. 자바스크립트를 이용해 코드를 적었으면 코드가 실행되는 곳이 런타임이다.</p></br><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>이전에는 JavaScript 런타임이 웹 브라우저 밖에 없었으나, node.js의 등장으로 브라우저가 아닌 곳에서 실행될 수 있게 되었다. </p><p>CLI에서  <code>node &lt;file name&gt;</code> 명령어를 입력 → 작성한 코드가 node.js 런타임으로 실행</p></br><hr><h2 id="nvm-amp-node-js"><a href="#nvm-amp-node-js" class="headerlink" title="nvm &amp; node.js"></a>nvm &amp; node.js</h2><p>nvm(Node Vesion Manager)을 이용하면 <strong>node.js의 다양한 버전을 설치, 사용</strong>할 수 있음</p></br><h3 id="nvm-설치"><a href="#nvm-설치" class="headerlink" title="nvm 설치"></a>nvm 설치</h3><p><a href="https://github.com/nvm-sh/nvm#install--update-script">GitHub - nvm-sh&#x2F;nvm: Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions</a></p></br><h3 id="설치-확인"><a href="#설치-확인" class="headerlink" title="설치 확인"></a>설치 확인</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5456302e-e7f5-4b7c-913b-9b1caa9d23b0/Untitled.png" alt="Untitled"></p><p>nvm 설치 성공시 화면 → <code>nvm -—version</code> 명령어로 버전 확인</p></br><h3 id="node-js-설치"><a href="#node-js-설치" class="headerlink" title="node.js 설치"></a>node.js 설치</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install <span class="literal">--lts</span> <span class="comment"># 최신 버전 설치</span></span><br><span class="line"></span><br><span class="line">node <span class="literal">-v</span> <span class="comment"># 버전 확인</span></span><br></pre></td></tr></table></figure><p><a href="https://nodejs.org/en/">Node.js</a></p></br><hr><h2 id="nvm-사용법"><a href="#nvm-사용법" class="headerlink" title="nvm 사용법"></a>nvm 사용법</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 설치된 버전</span></span><br><span class="line">nvm <span class="built_in">ls</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 특정 버전의 node 설치</span></span><br><span class="line">nvm install <span class="number">12.18</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 다른 버전으로 변경하여 사용</span></span><br><span class="line">nvm use 버전넘버 </span><br></pre></td></tr></table></figure></br><hr><h2 id="npm-과-package-json"><a href="#npm-과-package-json" class="headerlink" title="npm 과 package.json"></a>npm 과 package.json</h2><p><strong>남이 만들어놓은 검증된 코드(모듈)</strong> ⇒ npm 모듈</p><p>npm 모듈 활용을 위해 <strong>모듈 정보를 담아둔 파일</strong> ⇒ package.json </p><p>npm은 필요한 모듈을 다운로드할 수 있는, 모듈들이 모여있는 모듈 스토어이다.</p><p>macOS 패키지 매니저가 brew 이듯, node.js 생태계의 패키지 매니저는 npm 이다.</p></br><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>프로그램 실행을 위해 <strong>필요한 모듈들, 프로그램 실행 방법, 테스트 방법</strong> 등이 명시. 실제 모듈은 따로 node_modules 라는 폴더에 저장됨</p><p>프로젝트 코드를 전달시 <code>npm install</code> 명령어를 통해, package.json에서 필요하다고 하는 모듈을 다운로드 할 수 있다.</p></br><h3 id="dependency-의존성-모듈"><a href="#dependency-의존성-모듈" class="headerlink" title="dependency(의존성 모듈)"></a>dependency(의존성 모듈)</h3><p>프로그램 <strong>실행과 관계없이 개발을 위해 필요한 모듈</strong>. 개발이나 실행에 해당 모듈을 “의존”한다고 해서 <strong>“의존성 모듈”</strong>. <strong>키에 적힌 것은 모듈 이름, 값은 버전</strong>이다.</p><p><strong>devDependencies</strong> 에 프로젝트 개발하는 환경에서 필요한 모듈들이 무엇인지  적혀 있다.  </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mocha는 테스트를 위해 필요한 모듈</span></span><br><span class="line">npm install mocha <span class="literal">--save-dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --save-dev 옵션과 함께 install 실행시 자동으로 devDependencies에 추가</span></span><br></pre></td></tr></table></figure><p><strong>dependencies</strong> 는 직접 실행과 관련 있는 모듈. 프로젝트가 돌아가기 위해 반드시 필요한 모듈들이 적혀있음. underscore, React 등…</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^16.7.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^16.7.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># react 라이브러리 사용</span></span><br><span class="line">npm install react</span><br><span class="line">npm install <span class="literal">--save</span> react</span><br><span class="line"></span><br><span class="line"><span class="comment"># --save 옵션과 함께 install 실행시 자동으로 dependencies에 추가</span></span><br><span class="line"><span class="comment"># --save 생략 가능</span></span><br></pre></td></tr></table></figure></br><h3 id="scripts-항목"><a href="#scripts-항목" class="headerlink" title="scripts 항목"></a>scripts 항목</h3><p>CLI에서 사용가능한 명령을 기술(&#x3D;npm script)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mocha test/index.test.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;submit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;codestates-submission&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><aside>➡️ npm run <스크립트 이름> 으로 실행</aside><table><thead><tr><th>작업 내용</th><th>실행 스크립트</th></tr></thead><tbody><tr><td>node.js 앱 실행</td><td>npm run start</td></tr><tr><td>테스트 실행</td><td>npm run test</td></tr><tr><td>코드 검사</td><td>npm run lint</td></tr><tr><td>과제 제출(프로그램시)</td><td>npm run submit</td></tr></tbody></table><hr></br>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Web </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> Node.js </tag>
            
            <tag> Linux </tag>
            
            <tag> CLI </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML / CSS 기초</title>
      <link href="/2022/04/28/html-css/"/>
      <url>/2022/04/28/html-css/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-x2F-CSS-기초"><a href="#HTML-x2F-CSS-기초" class="headerlink" title="HTML &#x2F; CSS 기초"></a>HTML &#x2F; CSS 기초</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML?"></a>HTML?</h2><ul><li><strong>HyperText Markup Language</strong></li><li><strong>웹 페이지의 틀</strong>을 만드는 <strong>마크업 언어</strong></li></ul><br/><h3 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h3><ul><li>Html은 tag들의 집합</li><li>Tag : 부등호(&lt;&gt;)로 묶인 기본 구성 요소</li><li>html 확장자 사용</li></ul><br/><h3 id="TREE-STURCTURE"><a href="#TREE-STURCTURE" class="headerlink" title="TREE STURCTURE"></a>TREE STURCTURE</h3><ul><li>HTML 문서 시작 → <strong><!DOCTYPE html></strong><ul><li><strong>html</strong> → 시작 태그, 문서 전체의 틀 구성<ul><li><strong>head</strong> → 문서의 메타데이터 선언<ul><li><strong>title</strong> : Page title, 문서의 제목 → 브라우저 탭에 노출</li></ul></li><li><strong>body</strong> → 문서의 내용<ul><li><strong>h1</strong> → heading을 의미, 크기에 따라 h1~h6</li><li><strong>div</strong> : Content division → 줄바꿈 됨<ul><li><strong>span</strong> : Content Container → 줄바꿈 없음</li></ul></li></ul></li></ul></li></ul></li></ul><br/><h3 id="Most-Used-TAGS-in-HTML"><a href="#Most-Used-TAGS-in-HTML" class="headerlink" title="Most Used TAGS in HTML"></a>Most Used TAGS in HTML</h3><table><thead><tr><th>태그</th><th>설명</th></tr></thead><tbody><tr><td><strong>div</strong></td><td>Division</td></tr><tr><td><strong>span</strong></td><td>Span</td></tr><tr><td><strong>img</strong></td><td>Image</td></tr><tr><td><strong>a</strong></td><td>Link</td></tr><tr><td><strong>ul</strong> &amp; <strong>li</strong></td><td>Unorderd List &amp; List Item</td></tr><tr><td><strong>input</strong></td><td>Input (Text, Radio, Checkbox)</td></tr><tr><td><strong>textarea</strong></td><td>Multi-line Text Input</td></tr><tr><td><strong>button</strong></td><td>Button</td></tr></tbody></table><hr><br/><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS?"></a>CSS?</h2><p>HTML, CSS, 그리고 JS는 웹 어플리케이션을 만드는 세가지의 주축이다. CSS는 스타일링을 담당한다. </p><ul><li>콘텐츠의 배치와 위치 (레이아웃 디자인)</li><li>텍스트를 강조하거나 밑줄을 치는 등, 최소한의 타이포그래피 (Typography)</li></ul><p>위의 요소를 갖춘다면 더 나은 사용자 경험(UX, User Experience)을 제공할 수 있다.<br>CSS를 작성해서 간단한 UI를 만드는 것은 개발자의 기본적 소양이다. 콘텐츠를 적당한 위치에 배치하는 레이아웃 디자인은 디자이너가 아니라도 할 수 있어야 한다.</p><br/><h3 id="일반-사용자를-대상으로-하는-어플리케이션은-UI-User-Interface-가-없으면-소용이-없다"><a href="#일반-사용자를-대상으로-하는-어플리케이션은-UI-User-Interface-가-없으면-소용이-없다" class="headerlink" title="일반 사용자를 대상으로 하는 어플리케이션은, UI(User Interface)가 없으면 소용이 없다."></a>일반 사용자를 대상으로 하는 어플리케이션은, UI(User Interface)가 없으면 소용이 없다.</h3><p>사용자 인터페이스(UI)는 사람과 컴퓨터 프로그램이 소통할 수 있도록 만들어진 요소.<br>훌륭한 내부 기능도 UI가 없으면 소용이 없다.</p><br/><h3 id="프론트엔드-개발자에게-요구되는-능력"><a href="#프론트엔드-개발자에게-요구되는-능력" class="headerlink" title="프론트엔드 개발자에게 요구되는 능력"></a>프론트엔드 개발자에게 요구되는 능력</h3><ul><li>화면의 구성이나 배치 (레이아웃 디자인)</li><li>굵은 글씨와 같은 타이포그래피와 색상을 적용하는 일</li><li>정렬이나 배색에 대한 감각</li><li>UX에 대해 고민하고, 잘 적용된 웹이나 앱 예제를 분석해본 경험</li></ul><p><a href="https://medium.com/actualize-network/modern-css-explained-for-dinosaurs-5226febe3525">*Reference : Jang, p. → CSS 모범 사례</a></p><hr><p><strong>#시멘틱 태그</strong></p><p><a href="https://developer.mozilla.org/ko/docs/Web/HTML/Element#%EC%BD%98%ED%85%90%EC%B8%A0_%EA%B5%AC%ED%9A%8D">: 요소 참고 링크</a></p><br/><h3 id="CSS-문법-구성"><a href="#CSS-문법-구성" class="headerlink" title="CSS 문법 구성"></a>CSS 문법 구성</h3><p><img src="/image/Web/1.png"></p><p>셀렉터는 태그의 이름이나 id, class를 선택한다. 셀렉터로 특정 요소를 선택하고, 중괄호 안에 요소에 적용할 내용을 작성한다. 요소에 적용할 수 있는 내용을 속성이라고 한다. 색상이나 글자 크기등의 속성이 있다. 속성에 적용할 값을 입력하여 스타일을 표현한다. 속성과 값의 끝에는 세미콜론( ; )을 붙여 속성끼리 구분한다.</p><br/><h3 id="CSS-파일-추가하기"><a href="#CSS-파일-추가하기" class="headerlink" title="CSS 파일 추가하기"></a>CSS 파일 추가하기</h3><p>css 파일을 html 파일에 연결할 때는, <strong>link 태그 안에서 href 속성</strong>을 통해 파일을 연결한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">”stylesheet”</span> <span class="attr">href</span>=<span class="string">”index.css”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>link 태그는 HTML <strong>파일과 다른 파일을 연결</strong>하는 목적으로 사용한다. </p><p>→ <strong>rel</strong>은 연결하려는 <strong>파일의 역할이나 특징</strong>을 나타낸다. CSS는 Style sheet.<br>→ <strong>href</strong> 속성에는 <strong>파일의 위치</strong>를 추가해야 한다. 절대결로 혹은 상대경로를 입력.</p><br/><h3 id="CSS-스타일-적용법-3가지"><a href="#CSS-스타일-적용법-3가지" class="headerlink" title="CSS 스타일 적용법 (3가지)"></a>CSS 스타일 적용법 (3가지)</h3><ul><li><strong>인라인 스타일</strong> : 같은 줄에서 스타일 적용</li><li><strong>내부 스타일 시트</strong> : 별도의 파일로 구분하지 않고 style 태그 내에 작성</li><li><strong>외부 스타일 시트</strong> : CSS 파일 내에 작성하는 내용</li></ul><br/><h2 id="기본적인-셀렉터-selector"><a href="#기본적인-셀렉터-selector" class="headerlink" title="기본적인 셀렉터 (selector)"></a>기본적인 셀렉터 (selector)</h2><table><thead><tr><th>id</th><th>class</th></tr></thead><tbody><tr><td>#</td><td>.</td></tr><tr><td>한 문서에 단 하나의 요소에만 적용</td><td>동일한 값을 갖는 요소가 많음</td></tr><tr><td>특정 요소에 이름을 붙이는 데 사용</td><td>스타일의 분류(classification)에 사용</td></tr></tbody></table><hr><br/><h2 id="Font-글꼴"><a href="#Font-글꼴" class="headerlink" title="Font[글꼴]"></a>Font[글꼴]</h2><h3 id="웹-폰트-기술과-최신-동향"><a href="#웹-폰트-기술과-최신-동향" class="headerlink" title="웹 폰트 기술과 최신 동향"></a>웹 폰트 기술과 최신 동향</h3><p><a href="https://d2.naver.com/helloworld/4969726">NAVER D2</a></p><br/><h3 id="구글-폰트-Google-Fonts"><a href="#구글-폰트-Google-Fonts" class="headerlink" title="구글 폰트(Google Fonts)"></a>구글 폰트(Google Fonts)</h3><p><a href="https://fonts.google.com/">Google Fonts</a></p><p>⇒ HTML link 태그를 사용하여 간단하게 embed 가능</p><br/><h3 id="글자-크기"><a href="#글자-크기" class="headerlink" title="글자 크기"></a>글자 크기</h3><ul><li><strong>속성 → font-size: ;</strong><ul><li>절대 단위 : <strong>px, pt</strong></li><li>상대 단위 : <strong>%, em, rem, ch, vw, ch</strong></li></ul></li></ul><p>*참고 링크 : <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#numbers_lengths_and_percentages">MDN</a>, <a href="https://www.w3schools.com/cssref/css_units.asp">w3schools</a></p><ol><li><p>기기나 브라우저 사이즈 등의 <strong>환경에 영향을 받지 않는 절대적</strong>인 크기</p><ul><li><p><strong>px(픽셀)</strong> : px는 글꼴의 크기를 고정하는 단위. 사용자 접근성이 불리함.</p><p>  ⇒ 크기가 고정되어 인쇄와 같이 화면의 사이즈가 정해진 경우</p></li></ul></li><li><p>일반적인 경우</p><ul><li><p><strong>rem</strong> : <strong>상대 단위</strong>, root의 글자 크기(&#x3D;브라우저의 기본 글자 크기)는 1rem &#x2F; 두배로 크게 적용시 2rem &#x2F; 작게 적용 0.8rem 등 조절해서 사용</p><p>  ⇒ 사용자 설정 기본 글꼴 크기를 따라 접근성에 유리</p><p>  ⇒ em은 부모 엘리먼트에 따라 상대적으로 크기가 변경되어 계산이 어려움</p></li></ul></li><li><p><strong>반응형 웹(responsive web)에서 기준점</strong>을 만들 때</p><ul><li>반응형 웹은 디바이스 너비(width)에 따라 유동적인 레이아웃이 적용되는 엡사이트. 데스크탑, 스마트폰의 가로 모드-세로모드, 태블릿 등. 디바이스 크기 별로 CSS를 달리 적용해야 한다면 디바이스 크기를 나누는 기준은 보통 px로 정한다.</li></ul></li></ol><br/><h3 id="글자-스타일링"><a href="#글자-스타일링" class="headerlink" title="글자 스타일링"></a>글자 스타일링</h3><ul><li>굵기 : <strong>font-weight</strong></li><li>밑줄, 가로줄 : <strong>text-decoration</strong></li><li>자간 : <strong>letter-spacing</strong></li><li>행간 : <strong>line-height</strong></li></ul><br/><h3 id="정렬"><a href="#정렬" class="headerlink" title="정렬"></a>정렬</h3><ul><li>가로 정렬 : <strong>text-align</strong><ul><li>유효값 : <strong>left, right, center, justify(양쪽 정렬)</strong></li></ul></li><li>세로 정렬</li></ul><hr><h1 id="HTML-문서-레이아웃"><a href="#HTML-문서-레이아웃" class="headerlink" title="HTML 문서 레이아웃"></a>HTML 문서 레이아웃</h1><p><img src="/image/Web/2.png"></p><h3 id="줄바꿈이-되는-박스-block-x2F-옆으로-붙는-박스-inline-inline-block"><a href="#줄바꿈이-되는-박스-block-x2F-옆으로-붙는-박스-inline-inline-block" class="headerlink" title="줄바꿈이 되는 박스(block) &#x2F; 옆으로 붙는 박스(inline, inline-block)"></a>줄바꿈이 되는 박스(block) &#x2F; 옆으로 붙는 박스(inline, inline-block)</h3><ul><li><strong>block</strong> 박스 : 줄바꿈이 됨 ⇒ <strong><div> <p></strong></li><li><strong>inline</strong> 박스 : 줄바꿈 x, 크기지정이 불가능 ⇒ <strong><span></strong></li><li><strong>inline-block</strong> 박스 : 줄바꿈이 일어나지 않는 동시에 block 박스의 특징을 가짐</li></ul><br/><h3 id="줄바꿈이-되는-태그-x2F-되지-않는-태그"><a href="#줄바꿈이-되는-태그-x2F-되지-않는-태그" class="headerlink" title="줄바꿈이 되는 태그 &#x2F; 되지 않는 태그"></a>줄바꿈이 되는 태그 &#x2F; 되지 않는 태그</h3><ul><li><strong>줄바꿈</strong>이 되는 태그 : <strong><h1> <p></strong></li><li>줄바꿈이 되지 않는 태그 : <strong><span></strong></li></ul><p>→ <strong>개발자 도구</strong> elements tab : <strong>cmd + opt + i 단축키</strong></p><p>→ MDN <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements">block 엘리먼트 목록</a> &#x2F; <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements">inline 엘리먼트 요소</a></p><table><thead><tr><th></th><th>block</th><th>inline-block</th><th>inline</th></tr></thead><tbody><tr><td>줄바꿈</td><td>O</td><td>X</td><td>X</td></tr><tr><td>기본 너비 (width)</td><td>100%</td><td>글자가 차지하는 만큼</td><td>글자가 차지하는 만큼</td></tr><tr><td>width, height 사용</td><td>가능</td><td>가능</td><td>불가능</td></tr></tbody></table><hr><h1 id="박스-구성-요소"><a href="#박스-구성-요소" class="headerlink" title="박스 구성 요소"></a>박스 구성 요소</h1><p><img src="/image/Web/3.png"></p><h2 id="border-테두리"><a href="#border-테두리" class="headerlink" title="border (테두리)"></a>border (테두리)</h2><ul><li>border-<strong>width</strong> : 테두리 두께</li><li>border-<strong>style :</strong> 테두리 스타일</li><li>border-<strong>color</strong> : 테두리 색상</li><li>border-<strong>style mdn</strong> → 세부 속성 검색</li></ul><br/><h2 id="margin-바깥-여백"><a href="#margin-바깥-여백" class="headerlink" title="margin (바깥 여백)"></a>margin (바깥 여백)</h2><p>margint : <strong>top right bottom left</strong> ; ⇒ 값 하나만 적용시 모든 방향의 바깥 여백 적용</p><br/><h2 id="padding-안쪽-여백"><a href="#padding-안쪽-여백" class="headerlink" title="padding (안쪽 여백)"></a>padding (안쪽 여백)</h2><p>padding : <strong>top right bottom left</strong> ; ⇒ 값 하나만 적용시 모든 방향의 안쪽 여백 적용</p><br/><h2 id="박스를-벗어나는-컨텐츠-처리-⇒-overflow"><a href="#박스를-벗어나는-컨텐츠-처리-⇒-overflow" class="headerlink" title="박스를 벗어나는 컨텐츠 처리 ⇒ overflow"></a>박스를 벗어나는 컨텐츠 처리 ⇒ overflow</h2><p>박스 크기에 맞게 컨텐츠를 표시하지 않거나, 스크롤을 추가하여 확인하는 방법</p><ul><li><strong>overflow</strong> : (overflow-x &#x2F; overflow-y);<ul><li><strong>auto</strong> : 컨텐츠가 넘칠 때 스크롤 생성</li><li><strong>hidden</strong> : 컨텐츠가 넘칠 때 보이지 않기</li></ul></li></ul><br/><h2 id="셀렉터"><a href="#셀렉터" class="headerlink" title="셀렉터 *"></a>셀렉터 *</h2><p>모든 요소를 선택하는 셀렉터 * 에 속성 추가</p><p>→ <strong>box-sizing</strong> : border-box;</p><p>모든 박스에서 여백과 테두리를 포함한 크기로 계산</p><p><img src="/image/Web/4.png"></p><ul><li><strong>content-box</strong> : 박스 크기를 측정하는 기본값</li><li><strong>border-box</strong> : 여백과 테두리를 포함하는 박스 크기 계산법</li></ul><br/><hr><br/>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Web </tag>
            
            <tag> codestates </tag>
            
            <tag> BEB05 </tag>
            
            <tag> Html </tag>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
